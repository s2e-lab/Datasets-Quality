<source file="./systems/Original_Files/65.py" startline="2" endline="16">
def circular_shift(x, shift) :
INDENT
    s = str(x)
    if shift > len(s) :
    INDENT
        return s [: : - 1]
    DEDENT
    else :
    INDENT
        return s [len(s) - shift :] + s [: len(s) - shift]
    DEDENT
DEDENT
</source>
<source file="./systems/Original_Files/93.py" startline="2" endline="20">
def encode(message) :
INDENT
    vowels = "aeiouAEIOU"
    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])
    message = message.swapcase()
    return ''.join([vowels_replace [i] if i in vowels else i for i in message])
DEDENT
</source>
<source file="./systems/Original_Files/42.py" startline="3" endline="11">
def incr_list(l : list) :
INDENT
    return [(e + 1) for e in l]
DEDENT
</source>
<source file="./systems/Original_Files/53.py" startline="3" endline="11">
def add(x : int, y : int) :
INDENT
    return x + y
DEDENT
</source>
<source file="./systems/Original_Files/7.py" startline="4" endline="12">
def filter_by_substring(strings : List [str], substring : str) -> List [str] :
INDENT
    return [x for x in strings if substring in x]
DEDENT
</source>
<source file="./systems/Original_Files/111.py" startline="2" endline="28">
def histogram(test) :
INDENT
    dict1 = {}
    list1 = test.split(" ")
    t = 0
    for i in list1 :
    INDENT
        if (list1.count(i) > t) and i ! = '' :
        INDENT
            t = list1.count(i)
        DEDENT
    DEDENT
    if t > 0 :
    INDENT
        for i in list1 :
        INDENT
            if (list1.count(i) == t) :
            INDENT
                dict1 [i] = t
            DEDENT
        DEDENT
    DEDENT
    return dict1
DEDENT
</source>
<source file="./systems/Original_Files/86.py" startline="2" endline="16">
def anti_shuffle(s) :
INDENT
    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])
DEDENT
</source>
<source file="./systems/Original_Files/29.py" startline="4" endline="12">
def filter_by_prefix(strings : List [str], prefix : str) -> List [str] :
INDENT
    return [x for x in strings if x.startswith(prefix)]
DEDENT
</source>
<source file="./systems/Original_Files/63.py" startline="3" endline="24">
def fibfib(n : int) :
INDENT
    if n == 0 :
    INDENT
        return 0
    DEDENT
    if n == 1 :
    INDENT
        return 0
    DEDENT
    if n == 2 :
    INDENT
        return 1
    DEDENT
    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)
DEDENT
</source>
<source file="./systems/Original_Files/51.py" startline="3" endline="20">
def remove_vowels(text) :
INDENT
    return "".join([s for s in text if s.lower() not in ["a", "e", "i", "o", "u"]])
DEDENT
</source>
<source file="./systems/Original_Files/30.py" startline="3" endline="11">
def get_positive(l : list) :
INDENT
    return [e for e in l if e > 0]
DEDENT
</source>
<source file="./systems/Original_Files/54.py" startline="3" endline="20">
def same_chars(s0 : str, s1 : str) :
INDENT
    return set(s0) == set(s1)
DEDENT
</source>
<source file="./systems/Original_Files/20.py" startline="4" endline="28">
def find_closest_elements(numbers : List [float]) -> Tuple [float, float] :
INDENT
    closest_pair = None
    distance = None
    for idx, elem in enumerate(numbers) :
    INDENT
        for idx2, elem2 in enumerate(numbers) :
        INDENT
            if idx ! = idx2 :
            INDENT
                if distance is None :
                INDENT
                    distance = abs(elem - elem2)
                    closest_pair = tuple(sorted([elem, elem2]))
                DEDENT
                else :
                INDENT
                    new_distance = abs(elem - elem2)
                    if new_distance < distance :
                    INDENT
                        distance = new_distance
                        closest_pair = tuple(sorted([elem, elem2]))
                    DEDENT
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    return closest_pair
DEDENT
</source>
<source file="./systems/Original_Files/6.py" startline="4" endline="25">
def parse_nested_parens(paren_string : str) -> List [int] :
INDENT
    def parse_paren_group(s) :
    INDENT
        depth = 0
        max_depth = 0
        for c in s :
        INDENT
            if c == '(' :
            INDENT
                depth += 1
                max_depth = max(depth, max_depth)
            DEDENT
            else :
            INDENT
                depth -= 1
            DEDENT
        DEDENT
        return max_depth
    DEDENT
    return [parse_paren_group(x) for x in paren_string.split(' ') if x]
DEDENT
</source>
<source file="./systems/Original_Files/6.py" startline="13" endline="24">
def parse_paren_group(s) :
INDENT
    depth = 0
    max_depth = 0
    for c in s :
    INDENT
        if c == '(' :
        INDENT
            depth += 1
            max_depth = max(depth, max_depth)
        DEDENT
        else :
        INDENT
            depth -= 1
        DEDENT
    DEDENT
    return max_depth
DEDENT
</source>
<source file="./systems/Original_Files/88.py" startline="2" endline="18">
def sort_array(array) :
INDENT
    return [] if len(array) == 0 else sorted(array, reverse = (array [0] + array [- 1]) % 2 == 0)
DEDENT
</source>
<source file="./systems/Original_Files/145.py" startline="2" endline="20">
def order_by_points(nums) :
INDENT
    def digits_sum(n) :
    INDENT
        neg = 1
        if n < 0 : n, neg = - 1 * n, - 1
        n = [int(i) for i in str(n)]
        n [0] = n [0] * neg
        return sum(n)
    DEDENT
    return sorted(nums, key = digits_sum)
DEDENT
</source>
<source file="./systems/Original_Files/145.py" startline="14" endline="19">
def digits_sum(n) :
INDENT
    neg = 1
    if n < 0 : n, neg = - 1 * n, - 1
    n = [int(i) for i in str(n)]
    n [0] = n [0] * neg
    return sum(n)
DEDENT
</source>
<source file="./systems/Original_Files/109.py" startline="2" endline="41">
def move_one_ball(arr) :
INDENT
    if len(arr) == 0 :
    INDENT
        return True
    DEDENT
    sorted_array = sorted(arr)
    my_arr = []
    min_value = min(arr)
    min_index = arr.index(min_value)
    my_arr = arr [min_index :] + arr [0 : min_index]
    for i in range(len(arr)) :
    INDENT
        if my_arr [i] ! = sorted_array [i] :
        INDENT
            return False
        DEDENT
    DEDENT
    return True
DEDENT
</source>
<source file="./systems/Original_Files/126.py" startline="2" endline="29">
def is_sorted(lst) :
INDENT
    '''
    Given a list of numbers, return whether or not they are sorted
    in ascending order. If list has more than 1 duplicate of the same
    number, return False. Assume no negative numbers and only integers.

    Examples
    is_sorted([5]) ➞ True
    is_sorted([1, 2, 3, 4, 5]) ➞ True
    is_sorted([1, 3, 2, 4, 5]) ➞ False
    is_sorted([1, 2, 3, 4, 5, 6]) ➞ True
    is_sorted([1, 2, 3, 4, 5, 6, 7]) ➞ True
    is_sorted([1, 3, 2, 4, 5, 6, 7]) ➞ False
    is_sorted([1, 2, 2, 3, 3, 4]) ➞ True
    is_sorted([1, 2, 2, 2, 3, 4]) ➞ False
    '''
    count_digit = dict([(i, 0) for i in lst])
    for i in lst :
    INDENT
        count_digit [i] += 1
    DEDENT
    if any(count_digit [i] > 2 for i in lst) :
    INDENT
        return False
    DEDENT
    if all(lst [i - 1] < = lst [i] for i in range(1, len(lst))) :
    INDENT
        return True
    DEDENT
    else :
    INDENT
        return False

    DEDENT
DEDENT
</source>
<source file="./systems/Original_Files/123.py" startline="2" endline="33">
def get_odd_collatz(n) :
INDENT
    if n % 2 == 0 :
    INDENT
        odd_collatz = []
    DEDENT
    else :
    INDENT
        odd_collatz = [n]
    DEDENT
    while n > 1 :
    INDENT
        if n % 2 == 0 :
        INDENT
            n = n / 2
        DEDENT
        else :
        INDENT
            n = n * 3 + 1
        DEDENT
        if n % 2 == 1 :
        INDENT
            odd_collatz.append(int(n))
        DEDENT
    DEDENT
    return sorted(odd_collatz)
DEDENT
</source>
<source file="./systems/Original_Files/87.py" startline="2" endline="24">
def get_row(lst, x) :
INDENT
    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst [i])) if lst [i] [j] == x]
    return sorted(sorted(coords, key = lambda x : x [1], reverse = True), key = lambda x : x [0])
DEDENT
</source>
<source file="./systems/Original_Files/155.py" startline="2" endline="17">
def even_odd_count(num) :
INDENT
    even_count = 0
    odd_count = 0
    for i in str(abs(num)) :
    INDENT
        if int(i) % 2 == 0 :
        INDENT
            even_count += 1
        DEDENT
        else :
        INDENT
            odd_count += 1
        DEDENT
    DEDENT
    return (even_count, odd_count)
DEDENT
</source>
<source file="./systems/Original_Files/143.py" startline="2" endline="33">
def words_in_sentence(sentence) :
INDENT
    new_lst = []
    for word in sentence.split() :
    INDENT
        flg = 0
        if len(word) == 1 :
        INDENT
            flg = 1
        DEDENT
        for i in range(2, len(word)) :
        INDENT
            if len(word) % i == 0 :
            INDENT
                flg = 1
            DEDENT
        DEDENT
        if flg == 0 or len(word) == 2 :
        INDENT
            new_lst.append(word)
        DEDENT
    DEDENT
    return " ".join(new_lst)
DEDENT
</source>
<source file="./systems/Original_Files/31.py" startline="3" endline="26">
def is_prime(n) :
INDENT
    if n < 2 :
    INDENT
        return False
    DEDENT
    for k in range(2, n - 1) :
    INDENT
        if n % k == 0 :
        INDENT
            return False
        DEDENT
    DEDENT
    return True
DEDENT
</source>
<source file="./systems/Original_Files/101.py" startline="2" endline="24">
def words_string(s) :
INDENT
    if not s :
    INDENT
        return []
    DEDENT
    s_list = []
    for letter in s :
    INDENT
        if letter == ',' :
        INDENT
            s_list.append(' ')
        DEDENT
        else :
        INDENT
            s_list.append(letter)
        DEDENT
    DEDENT
    s_list = "".join(s_list)
    return s_list.split()
DEDENT
</source>
<source file="./systems/Original_Files/9.py" startline="4" endline="22">
def rolling_max(numbers : List [int]) -> List [int] :
INDENT
    running_max = None
    result = []
    for n in numbers :
    INDENT
        if running_max is None :
        INDENT
            running_max = n
        DEDENT
        else :
        INDENT
            running_max = max(running_max, n)
        DEDENT
        result.append(running_max)
    DEDENT
    return result
DEDENT
</source>
<source file="./systems/Original_Files/5.py" startline="4" endline="23">
def intersperse(numbers : List [int], delimeter : int) -> List [int] :
INDENT
    if not numbers :
    INDENT
        return []
    DEDENT
    result = []
    for n in numbers [: - 1] :
    INDENT
        result.append(n)
        result.append(delimeter)
    DEDENT
    result.append(numbers [- 1])
    return result
DEDENT
</source>
<source file="./systems/Original_Files/162.py" startline="2" endline="11">
def string_to_md5(text) :
INDENT
    import hashlib
    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None
DEDENT
</source>
<source file="./systems/Original_Files/62.py" startline="3" endline="13">
def derivative(xs : list) :
INDENT
    return [(i * x) for i, x in enumerate(xs)] [1 :]
DEDENT
</source>
<source file="./systems/Original_Files/40.py" startline="3" endline="26">
def triples_sum_to_zero(l : list) :
INDENT
    for i in range(len(l)) :
    INDENT
        for j in range(i + 1, len(l)) :
        INDENT
            for k in range(j + 1, len(l)) :
            INDENT
                if l [i] + l [j] + l [k] == 0 :
                INDENT
                    return True
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    return False
DEDENT
</source>
<source file="./systems/Original_Files/119.py" startline="2" endline="31">
def match_parens(lst) :
INDENT
    '''
    You are given a list of two strings, both strings consist of open
    parentheses '(' or close parentheses ')' only.
    Your job is to check if it is possible to concatenate the two strings in
    some order, that the resulting string will be good.
    A string S is considered to be good if and only if all parentheses in S
    are balanced. For example: the string '(())()' is good, while the string
    '())' is not.
    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.

    Examples:
    match_parens(['()(', ')']) == 'Yes'
    match_parens([')', ')']) == 'No'
    '''
    def check(s) :
    INDENT
        val = 0
        for i in s :
        INDENT
            if i == '(' :
            INDENT
                val = val + 1
            DEDENT
            else :
            INDENT
                val = val - 1
            DEDENT
            if val < 0 :
            INDENT
                return False
            DEDENT
        DEDENT
        return True if val == 0 else False
    DEDENT
    S1 = lst [0] + lst [1]
    S2 = lst [1] + lst [0]
    return 'Yes' if check(S1) or check(S2) else 'No'
DEDENT
</source>
<source file="./systems/Original_Files/119.py" startline="18" endline="28">
def check(s) :
INDENT
    val = 0
    for i in s :
    INDENT
        if i == '(' :
        INDENT
            val = val + 1
        DEDENT
        else :
        INDENT
            val = val - 1
        DEDENT
        if val < 0 :
        INDENT
            return False
        DEDENT
    DEDENT
    return True if val == 0 else False
DEDENT
</source>
<source file="./systems/Original_Files/37.py" startline="3" endline="21">
def sort_even(l : list) :
INDENT
    evens = l [: : 2]
    odds = l [1 : : 2]
    evens.sort()
    ans = []
    for e, o in zip(evens, odds) :
    INDENT
        ans.extend([e, o])
    DEDENT
    if len(evens) > len(odds) :
    INDENT
        ans.append(evens [- 1])
    DEDENT
    return ans
DEDENT
</source>
<source file="./systems/Original_Files/41.py" startline="3" endline="16">
def car_race_collision(n : int) :
INDENT
    return n ** 2
DEDENT
</source>
<source file="./systems/Original_Files/72.py" startline="2" endline="30">
def will_it_fly(q, w) :
INDENT
    '''
    Write a function that returns True if the object q will fly, and False otherwise.
    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.

    Example:
    will_it_fly([1, 2], 5) ➞ False 
    # 1+2 is less than the maximum possible weight, but it's unbalanced.

    will_it_fly([3, 2, 3], 1) ➞ False
    # it's balanced, but 3+2+3 is more than the maximum possible weight.

    will_it_fly([3, 2, 3], 9) ➞ True
    # 3+2+3 is less than the maximum possible weight, and it's balanced.

    will_it_fly([3], 5) ➞ True
    # 3 is less than the maximum possible weight, and it's balanced.
    '''
    if sum(q) > w :
    INDENT
        return False
    DEDENT
    i, j = 0, len(q) - 1
    while i < j :
    INDENT
        if q [i] ! = q [j] :
        INDENT
            return False
        DEDENT
        i += 1
        j -= 1
    DEDENT
    return True
DEDENT
</source>
<source file="./systems/Original_Files/142.py" startline="4" endline="24">
def sum_squares(lst) :
INDENT
    result = []
    for i in range(len(lst)) :
    INDENT
        if i % 3 == 0 :
        INDENT
            result.append(lst [i] ** 2)
        DEDENT
        elif i % 4 == 0 and i % 3 ! = 0 :
        INDENT
            result.append(lst [i] ** 3)
        DEDENT
        else :
        INDENT
            result.append(lst [i])
        DEDENT
    DEDENT
    return sum(result)
DEDENT
</source>
<source file="./systems/Original_Files/74.py" startline="2" endline="28">
def total_match(lst1, lst2) :
INDENT
    '''
    Write a function that accepts two lists of strings and returns the list that has 
    total number of chars in the all strings of the list less than the other list.

    if the two lists have the same number of chars, return the first list.

    Examples
    total_match([], []) ➞ []
    total_match(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']
    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']
    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']
    total_match(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']
    '''
    l1 = 0
    for st in lst1 :
    INDENT
        l1 += len(st)
    DEDENT
    l2 = 0
    for st in lst2 :
    INDENT
        l2 += len(st)
    DEDENT
    if l1 < = l2 :
    INDENT
        return lst1
    DEDENT
    else :
    INDENT
        return lst2
    DEDENT
DEDENT
</source>
<source file="./systems/Original_Files/122.py" startline="2" endline="17">
def add_elements(arr, k) :
INDENT
    return sum(elem for elem in arr [: k] if len(str(elem)) < = 2)
DEDENT
</source>
<source file="./systems/Original_Files/114.py" startline="2" endline="21">
def minSubArraySum(nums) :
INDENT
    max_sum = 0
    s = 0
    for num in nums :
    INDENT
        s += - num
        if (s < 0) :
        INDENT
            s = 0
        DEDENT
        max_sum = max(s, max_sum)
    DEDENT
    if max_sum == 0 :
    INDENT
        max_sum = max(- i for i in nums)
    DEDENT
    min_sum = - max_sum
    return min_sum
DEDENT
</source>
<source file="./systems/Original_Files/58.py" startline="3" endline="17">
def common(l1 : list, l2 : list) :
INDENT
    ret = set()
    for e1 in l1 :
    INDENT
        for e2 in l2 :
        INDENT
            if e1 == e2 :
            INDENT
                ret.add(e1)
            DEDENT
        DEDENT
    DEDENT
    return sorted(list(ret))
DEDENT
</source>
<source file="./systems/Original_Files/3.py" startline="4" endline="21">
def below_zero(operations : List [int]) -> bool :
INDENT
    balance = 0
    for op in operations :
    INDENT
        balance += op
        if balance < 0 :
        INDENT
            return True
        DEDENT
    DEDENT
    return False
DEDENT
</source>
<source file="./systems/Original_Files/70.py" startline="2" endline="19">
def strange_sort_list(lst) :
INDENT
    '''
    Given list of integers, return list in strange order.
    Strange sorting, is when you start with the minimum value,
    then maximum of the remaining integers, then minimum and so on.

    Examples:
    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]
    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]
    strange_sort_list([]) == []
    '''
    res, switch = [], True
    while lst :
    INDENT
        res.append(min(lst) if switch else max(lst))
        lst.remove(res [- 1])
        switch = not switch
    DEDENT
    return res
DEDENT
</source>
<source file="./systems/Original_Files/59.py" startline="3" endline="22">
def largest_prime_factor(n : int) :
INDENT
    def is_prime(k) :
    INDENT
        if k < 2 :
        INDENT
            return False
        DEDENT
        for i in range(2, k - 1) :
        INDENT
            if k % i == 0 :
            INDENT
                return False
            DEDENT
        DEDENT
        return True
    DEDENT
    largest = 1
    for j in range(2, n + 1) :
    INDENT
        if n % j == 0 and is_prime(j) :
        INDENT
            largest = max(largest, j)
        DEDENT
    DEDENT
    return largest
DEDENT
</source>
<source file="./systems/Original_Files/59.py" startline="11" endline="17">
def is_prime(k) :
INDENT
    if k < 2 :
    INDENT
        return False
    DEDENT
    for i in range(2, k - 1) :
    INDENT
        if k % i == 0 :
        INDENT
            return False
        DEDENT
    DEDENT
    return True
DEDENT
</source>
<source file="./systems/Original_Files/25.py" startline="4" endline="28">
def factorize(n : int) -> List [int] :
INDENT
    import math
    fact = []
    i = 2
    while i < = int(math.sqrt(n) + 1) :
    INDENT
        if n % i == 0 :
        INDENT
            fact.append(i)
            n //= i
        DEDENT
        else :
        INDENT
            i += 1
        DEDENT
    DEDENT
    if n > 1 :
    INDENT
        fact.append(n)
    DEDENT
    return fact
DEDENT
</source>
<source file="./systems/Original_Files/78.py" startline="2" endline="26">
def hex_key(num) :
INDENT
    primes = ('2', '3', '5', '7', 'B', 'D')
    total = 0
    for i in range(0, len(num)) :
    INDENT
        if num [i] in primes :
        INDENT
            total += 1
        DEDENT
    DEDENT
    return total
DEDENT
</source>
<source file="./systems/Original_Files/15.py" startline="3" endline="11">
def string_sequence(n : int) -> str :
INDENT
    return ' '.join([str(x) for x in range(n + 1)])
DEDENT
</source>
<source file="./systems/Original_Files/61.py" startline="3" endline="25">
def correct_bracketing(brackets : str) :
INDENT
    depth = 0
    for b in brackets :
    INDENT
        if b == "(" :
        INDENT
            depth += 1
        DEDENT
        else :
        INDENT
            depth -= 1
        DEDENT
        if depth < 0 :
        INDENT
            return False
        DEDENT
    DEDENT
    return depth == 0
DEDENT
</source>
<source file="./systems/Original_Files/150.py" startline="2" endline="19">
def x_or_y(n, x, y) :
INDENT
    if n == 1 :
    INDENT
        return y
    DEDENT
    for i in range(2, n) :
    INDENT
        if n % i == 0 :
        INDENT
            return y
            break
        DEDENT
    DEDENT
    else :
    INDENT
        return x
    DEDENT
DEDENT
</source>
<source file="./systems/Original_Files/95.py" startline="2" endline="36">
def check_dict_case(dict) :
INDENT
    if len(dict.keys()) == 0 :
    INDENT
        return False
    DEDENT
    else :
    INDENT
        state = "start"
        for key in dict.keys() :
        INDENT
            if isinstance(key, str) == False :
            INDENT
                state = "mixed"
                break
            DEDENT
            if state == "start" :
            INDENT
                if key.isupper() :
                INDENT
                    state = "upper"
                DEDENT
                elif key.islower() :
                INDENT
                    state = "lower"
                DEDENT
                else :
                INDENT
                    break
                DEDENT
            DEDENT
            elif (state == "upper" and not key.isupper()) or (state == "lower" and not key.islower()) :
            INDENT
                state = "mixed"
                break
            DEDENT
            else :
            INDENT
                break
            DEDENT
        DEDENT
        return state == "upper" or state == "lower"
    DEDENT
DEDENT
</source>
<source file="./systems/Original_Files/110.py" startline="2" endline="27">
def exchange(lst1, lst2) :
INDENT
    odd = 0
    even = 0
    for i in lst1 :
    INDENT
        if i % 2 == 1 :
        INDENT
            odd += 1
        DEDENT
    DEDENT
    for i in lst2 :
    INDENT
        if i % 2 == 0 :
        INDENT
            even += 1
        DEDENT
    DEDENT
    if even > = odd :
    INDENT
        return "YES"
    DEDENT
    return "NO"
DEDENT
</source>
<source file="./systems/Original_Files/24.py" startline="3" endline="11">
def largest_divisor(n : int) -> int :
INDENT
    for i in reversed(range(n)) :
    INDENT
        if n % i == 0 :
        INDENT
            return i
        DEDENT
    DEDENT
DEDENT
</source>
<source file="./systems/Original_Files/8.py" startline="4" endline="19">
def sum_product(numbers : List [int]) -> Tuple [int, int] :
INDENT
    sum_value = 0
    prod_value = 1
    for n in numbers :
    INDENT
        sum_value += n
        prod_value *= n
    DEDENT
    return sum_value, prod_value
DEDENT
</source>
<source file="./systems/Original_Files/157.py" startline="2" endline="13">
def right_angle_triangle(a, b, c) :
INDENT
    '''
    Given the lengths of the three sides of a triangle. Return True if the three
    sides form a right-angled triangle, False otherwise.
    A right-angled triangle is a triangle in which one angle is right angle or 
    90 degree.
    Example:
    right_angle_triangle(3, 4, 5) == True
    right_angle_triangle(1, 2, 3) == False
    '''
    return a * a == b * b + c * c or b * b == a * a + c * c or c * c == a * a + b * b
DEDENT
</source>
<source file="./systems/Original_Files/47.py" startline="3" endline="15">
def median(l : list) :
INDENT
    l = sorted(l)
    if len(l) % 2 == 1 :
    INDENT
        return l [len(l) / / 2]
    DEDENT
    else :
    INDENT
        return (l [len(l) / / 2 - 1] + l [len(l) / / 2]) / 2.0
    DEDENT
DEDENT
</source>
<source file="./systems/Original_Files/49.py" startline="3" endline="20">
def modp(n : int, p : int) :
INDENT
    ret = 1
    for i in range(n) :
    INDENT
        ret = (2 * ret) % p
    DEDENT
    return ret
DEDENT
</source>
<source file="./systems/Original_Files/132.py" startline="2" endline="33">
def is_nested(string) :
INDENT
    '''
    Create a function that takes a string as input which contains only square brackets.
    The function should return True if and only if there is a valid subsequence of brackets 
    where at least one bracket in the subsequence is nested.

    is_nested('[[]]') ➞ True
    is_nested('[]]]]]]][[[[[]') ➞ False
    is_nested('[][]') ➞ False
    is_nested('[]') ➞ False
    is_nested('[[][]]') ➞ True
    is_nested('[[]][[') ➞ True
    '''
    opening_bracket_index = []
    closing_bracket_index = []
    for i in range(len(string)) :
    INDENT
        if string [i] == '[' :
        INDENT
            opening_bracket_index.append(i)
        DEDENT
        else :
        INDENT
            closing_bracket_index.append(i)
        DEDENT
    DEDENT
    closing_bracket_index.reverse()
    cnt = 0
    i = 0
    l = len(closing_bracket_index)
    for idx in opening_bracket_index :
    INDENT
        if i < l and idx < closing_bracket_index [i] :
        INDENT
            cnt += 1
            i += 1
        DEDENT
    DEDENT
    return cnt > = 2

DEDENT
</source>
<source file="./systems/Original_Files/2.py" startline="3" endline="13">
def truncate_number(number : float) -> float :
INDENT
    return number % 1.0
DEDENT
</source>
<source file="./systems/Original_Files/21.py" startline="4" endline="13">
def rescale_to_unit(numbers : List [float]) -> List [float] :
INDENT
    min_number = min(numbers)
    max_number = max(numbers)
    return [(x - min_number) / (max_number - min_number) for x in numbers]
DEDENT
</source>
<source file="./systems/Original_Files/69.py" startline="2" endline="23">
def search(lst) :
INDENT
    '''
    You are given a non-empty list of positive integers. Return the greatest integer that is greater than 
    zero, and has a frequency greater than or equal to the value of the integer itself. 
    The frequency of an integer is the number of times it appears in the list.
    If no such a value exist, return -1.
    Examples:
        search([4, 1, 2, 2, 3, 1]) == 2
        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3
        search([5, 5, 4, 4, 4]) == -1
    '''
    frq = [0] * (max(lst) + 1)
    for i in lst :
    INDENT
        frq [i] += 1;
    DEDENT
    ans = - 1
    for i in range(1, len(frq)) :
    INDENT
        if frq [i] > = i :
        INDENT
            ans = i
        DEDENT
    DEDENT
    return ans
DEDENT
</source>
<source file="./systems/Original_Files/112.py" startline="2" endline="15">
def reverse_delete(s, c) :
INDENT
    s = ''.join([char for char in s if char not in c])
    return (s, s [: : - 1] == s)
DEDENT
</source>
<source file="./systems/Original_Files/146.py" startline="2" endline="20">
def specialFilter(nums) :
INDENT
    count = 0
    for num in nums :
    INDENT
        if num > 10 :
        INDENT
            odd_digits = (1, 3, 5, 7, 9)
            number_as_string = str(num)
            if int(number_as_string [0]) in odd_digits and int(number_as_string [- 1]) in odd_digits :
            INDENT
                count += 1
            DEDENT
        DEDENT
    DEDENT
    return count
DEDENT
</source>
<source file="./systems/Original_Files/148.py" startline="2" endline="27">
def bf(planet1, planet2) :
INDENT
    '''
    There are eight planets in our solar system: the closerst to the Sun 
    is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, 
    Uranus, Neptune.
    Write a function that takes two planet names as strings planet1 and planet2. 
    The function should return a tuple containing all planets whose orbits are 
    located between the orbit of planet1 and the orbit of planet2, sorted by 
    the proximity to the sun. 
    The function should return an empty tuple if planet1 or planet2
    are not correct planet names. 
    Examples
    bf("Jupiter", "Neptune") ==> ("Saturn", "Uranus")
    bf("Earth", "Mercury") ==> ("Venus")
    bf("Mercury", "Uranus") ==> ("Venus", "Earth", "Mars", "Jupiter", "Saturn")
    '''
    planet_names = ("Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune")
    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2 :
    INDENT
        return ()
    DEDENT
    planet1_index = planet_names.index(planet1)
    planet2_index = planet_names.index(planet2)
    if planet1_index < planet2_index :
    INDENT
        return (planet_names [planet1_index + 1 : planet2_index])
    DEDENT
    else :
    INDENT
        return (planet_names [planet2_index + 1 : planet1_index])
    DEDENT
DEDENT
</source>
<source file="./systems/Original_Files/107.py" startline="2" endline="37">
def even_odd_palindrome(n) :
INDENT
    def is_palindrome(n) :
    INDENT
        return str(n) == str(n) [: : - 1]
    DEDENT
    even_palindrome_count = 0
    odd_palindrome_count = 0
    for i in range(1, n + 1) :
    INDENT
        if i % 2 == 1 and is_palindrome(i) :
        INDENT
            odd_palindrome_count += 1
        DEDENT
        elif i % 2 == 0 and is_palindrome(i) :
        INDENT
            even_palindrome_count += 1
        DEDENT
    DEDENT
    return (even_palindrome_count, odd_palindrome_count)
DEDENT
</source>
<source file="./systems/Original_Files/107.py" startline="26" endline="28">
def is_palindrome(n) :
INDENT
    return str(n) == str(n) [: : - 1]
DEDENT
</source>
<source file="./systems/Original_Files/159.py" startline="2" endline="35">
def eat(number, need, remaining) :
INDENT
    if (need < = remaining) :
    INDENT
        return [number + need, remaining - need]
    DEDENT
    else :
    INDENT
        return [number + remaining, 0]
    DEDENT
DEDENT
</source>
<source file="./systems/Original_Files/121.py" startline="2" endline="12">
def solution(lst) :
INDENT
    return sum([x for idx, x in enumerate(lst) if idx % 2 == 0 and x % 2 == 1])
DEDENT
</source>
<source file="./systems/Original_Files/158.py" startline="2" endline="13">
def find_max(words) :
INDENT
    return sorted(words, key = lambda x : (- len(set(x)), x)) [0]
DEDENT
</source>
<source file="./systems/Original_Files/10.py" startline="3" endline="7">
def is_palindrome(string : str) -> bool :
INDENT
    return string == string [: : - 1]

DEDENT
</source>
<source file="./systems/Original_Files/10.py" startline="8" endline="29">
def make_palindrome(string : str) -> str :
INDENT
    if not string :
    INDENT
        return ''
    DEDENT
    beginning_of_suffix = 0
    while not is_palindrome(string [beginning_of_suffix :]) :
    INDENT
        beginning_of_suffix += 1
    DEDENT
    return string + string [: beginning_of_suffix] [: : - 1]
DEDENT
</source>
<source file="./systems/Original_Files/98.py" startline="2" endline="16">
def count_upper(s) :
INDENT
    count = 0
    for i in range(0, len(s), 2) :
    INDENT
        if s [i] in "AEIOU" :
        INDENT
            count += 1
        DEDENT
    DEDENT
    return count
DEDENT
</source>
<source file="./systems/Original_Files/0.py" startline="4" endline="20">
def has_close_elements(numbers : List [float], threshold : float) -> bool :
INDENT
    for idx, elem in enumerate(numbers) :
    INDENT
        for idx2, elem2 in enumerate(numbers) :
        INDENT
            if idx ! = idx2 :
            INDENT
                distance = abs(elem - elem2)
                if distance < threshold :
                INDENT
                    return True
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    return False
DEDENT
</source>
<source file="./systems/Original_Files/156.py" startline="2" endline="27">
def int_to_mini_roman(number) :
INDENT
    num = [1, 4, 5, 9, 10, 40, 50, 90,
        100, 400, 500, 900, 1000]
    sym = ["I", "IV", "V", "IX", "X", "XL",
        "L", "XC", "C", "CD", "D", "CM", "M"]
    i = 12
    res = ''
    while number :
    INDENT
        div = number / / num [i]
        number %= num [i]
        while div :
        INDENT
            res += sym [i]
            div -= 1
        DEDENT
        i -= 1
    DEDENT
    return res.lower()
DEDENT
</source>
<source file="./systems/Original_Files/34.py" startline="3" endline="9">
def unique(l : list) :
INDENT
    return sorted(list(set(l)))
DEDENT
</source>
<source file="./systems/Original_Files/52.py" startline="3" endline="14">
def below_threshold(l : list, t : int) :
INDENT
    for e in l :
    INDENT
        if e > = t :
        INDENT
            return False
        DEDENT
    DEDENT
    return True
DEDENT
</source>
<source file="./systems/Original_Files/83.py" startline="2" endline="9">
def starts_one_ends(n) :
INDENT
    if n == 1 : return 1
    return 18 * (10 ** (n - 2))
DEDENT
</source>
<source file="./systems/Original_Files/163.py" startline="2" endline="16">
def generate_integers(a, b) :
INDENT
    lower = max(2, min(a, b))
    upper = min(8, max(a, b))
    return [i for i in range(lower, upper + 1) if i % 2 == 0]
DEDENT
</source>
<source file="./systems/Original_Files/133.py" startline="3" endline="21">
def sum_squares(lst) :
INDENT
    import math
    squared = 0
    for i in lst :
    INDENT
        squared += math.ceil(i) ** 2
    DEDENT
    return squared
DEDENT
</source>
<source file="./systems/Original_Files/39.py" startline="3" endline="33">
def prime_fib(n : int) :
INDENT
    import math
    def is_prime(p) :
    INDENT
        if p < 2 :
        INDENT
            return False
        DEDENT
        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)) :
        INDENT
            if p % k == 0 :
            INDENT
                return False
            DEDENT
        DEDENT
        return True
    DEDENT
    f = [0, 1]
    while True :
    INDENT
        f.append(f [- 1] + f [- 2])
        if is_prime(f [- 1]) :
        INDENT
            n -= 1
        DEDENT
        if n == 0 :
        INDENT
            return f [- 1]
        DEDENT
    DEDENT
DEDENT
</source>
<source file="./systems/Original_Files/39.py" startline="20" endline="26">
def is_prime(p) :
INDENT
    if p < 2 :
    INDENT
        return False
    DEDENT
    for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)) :
    INDENT
        if p % k == 0 :
        INDENT
            return False
        DEDENT
    DEDENT
    return True
DEDENT
</source>
<source file="./systems/Original_Files/60.py" startline="3" endline="17">
def sum_to_n(n : int) :
INDENT
    return sum(range(n + 1))
DEDENT
</source>
<source file="./systems/Original_Files/57.py" startline="3" endline="15">
def monotonic(l : list) :
INDENT
    if l == sorted(l) or l == sorted(l, reverse = True) :
    INDENT
        return True
    DEDENT
    return False
DEDENT
</source>
<source file="./systems/Original_Files/55.py" startline="3" endline="17">
def fib(n : int) :
INDENT
    if n == 0 :
    INDENT
        return 0
    DEDENT
    if n == 1 :
    INDENT
        return 1
    DEDENT
    return fib(n - 1) + fib(n - 2)
DEDENT
</source>
<source file="./systems/Original_Files/11.py" startline="4" endline="17">
def string_xor(a : str, b : str) -> str :
INDENT
    def xor(i, j) :
    INDENT
        if i == j :
        INDENT
            return '0'
        DEDENT
        else :
        INDENT
            return '1'
        DEDENT
    DEDENT
    return ''.join(xor(x, y) for x, y in zip(a, b))
DEDENT
</source>
<source file="./systems/Original_Files/11.py" startline="11" endline="16">
def xor(i, j) :
INDENT
    if i == j :
    INDENT
        return '0'
    DEDENT
    else :
    INDENT
        return '1'
    DEDENT
DEDENT
</source>
<source file="./systems/Original_Files/80.py" startline="2" endline="22">
def is_happy(s) :
INDENT
    if len(s) < 3 :
    INDENT
        return False
    DEDENT
    for i in range(len(s) - 2) :
    INDENT
        if s [i] == s [i + 1] or s [i + 1] == s [i + 2] or s [i] == s [i + 2] :
        INDENT
            return False
        DEDENT
    DEDENT
    return True
DEDENT
</source>
<source file="./systems/Original_Files/56.py" startline="3" endline="25">
def correct_bracketing(brackets : str) :
INDENT
    depth = 0
    for b in brackets :
    INDENT
        if b == "<" :
        INDENT
            depth += 1
        DEDENT
        else :
        INDENT
            depth -= 1
        DEDENT
        if depth < 0 :
        INDENT
            return False
        DEDENT
    DEDENT
    return depth == 0
DEDENT
</source>
<source file="./systems/Original_Files/64.py" startline="6" endline="23">
def vowels_count(s) :
INDENT
    vowels = "aeiouAEIOU"
    n_vowels = sum(c in vowels for c in s)
    if s [- 1] == 'y' or s [- 1] == 'Y' :
    INDENT
        n_vowels += 1
    DEDENT
    return n_vowels
DEDENT
</source>
<source file="./systems/Original_Files/125.py" startline="2" endline="18">
def split_words(txt) :
INDENT
    '''
    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you
    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the
    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25
    Examples
    split_words("Hello world!") ➞ ["Hello", "world!"]
    split_words("Hello,world!") ➞ ["Hello", "world!"]
    split_words("abcdef") == 3 
    '''
    if " " in txt :
    INDENT
        return txt.split()
    DEDENT
    elif "," in txt :
    INDENT
        return txt.replace(',', ' ').split()
    DEDENT
    else :
    INDENT
        return len([i for i in txt if i.islower() and ord(i) % 2 == 0])
    DEDENT
DEDENT
</source>
<source file="./systems/Original_Files/79.py" startline="2" endline="15">
def decimal_to_binary(decimal) :
INDENT
    return "db" + bin(decimal) [2 :] + "db"
DEDENT
</source>
<source file="./systems/Original_Files/127.py" startline="2" endline="38">
def intersection(interval1, interval2) :
INDENT
    def is_prime(num) :
    INDENT
        if num == 1 or num == 0 :
        INDENT
            return False
        DEDENT
        if num == 2 :
        INDENT
            return True
        DEDENT
        for i in range(2, num) :
        INDENT
            if num % i == 0 :
            INDENT
                return False
            DEDENT
        DEDENT
        return True
    DEDENT
    l = max(interval1 [0], interval2 [0])
    r = min(interval1 [1], interval2 [1])
    length = r - l
    if length > 0 and is_prime(length) :
    INDENT
        return "YES"
    DEDENT
    return "NO"
DEDENT
</source>
<source file="./systems/Original_Files/127.py" startline="23" endline="32">
def is_prime(num) :
INDENT
    if num == 1 or num == 0 :
    INDENT
        return False
    DEDENT
    if num == 2 :
    INDENT
        return True
    DEDENT
    for i in range(2, num) :
    INDENT
        if num % i == 0 :
        INDENT
            return False
        DEDENT
    DEDENT
    return True
DEDENT
</source>
<source file="./systems/Original_Files/17.py" startline="4" endline="19">
def parse_music(music_string : str) -> List [int] :
INDENT
    note_map = {'o' : 4, 'o|' : 2, '.|' : 1}
    return [note_map [x] for x in music_string.split(' ') if x]
DEDENT
</source>
<source file="./systems/Original_Files/44.py" startline="3" endline="19">
def change_base(x : int, base : int) :
INDENT
    ret = ""
    while x > 0 :
    INDENT
        ret = str(x % base) + ret
        x //= base
    DEDENT
    return ret
DEDENT
</source>
<source file="./systems/Original_Files/108.py" startline="2" endline="19">
def count_nums(arr) :
INDENT
    def digits_sum(n) :
    INDENT
        neg = 1
        if n < 0 : n, neg = - 1 * n, - 1
        n = [int(i) for i in str(n)]
        n [0] = n [0] * neg
        return sum(n)
    DEDENT
    return len(list(filter(lambda x : x > 0, [digits_sum(i) for i in arr])))
DEDENT
</source>
<source file="./systems/Original_Files/108.py" startline="13" endline="18">
def digits_sum(n) :
INDENT
    neg = 1
    if n < 0 : n, neg = - 1 * n, - 1
    n = [int(i) for i in str(n)]
    n [0] = n [0] * neg
    return sum(n)
DEDENT
</source>
<source file="./systems/Original_Files/50.py" startline="3" endline="9">
def encode_shift(s : str) :
INDENT
    return "".join([chr(((ord(ch) + 5 - ord("a")) % 26) + ord("a")) for ch in s])

DEDENT
</source>
<source file="./systems/Original_Files/50.py" startline="10" endline="15">
def decode_shift(s : str) :
INDENT
    return "".join([chr(((ord(ch) - 5 - ord("a")) % 26) + ord("a")) for ch in s])
DEDENT
</source>
<source file="./systems/Original_Files/82.py" startline="2" endline="18">
def prime_length(string) :
INDENT
    l = len(string)
    if l == 0 or l == 1 :
    INDENT
        return False
    DEDENT
    for i in range(2, l) :
    INDENT
        if l % i == 0 :
        INDENT
            return False
        DEDENT
    DEDENT
    return True
DEDENT
</source>
<source file="./systems/Original_Files/151.py" startline="2" endline="15">
def double_the_difference(lst) :
INDENT
    '''
    Given a list of numbers, return the sum of squares of the numbers
    in the list that are odd. Ignore numbers that are negative or not integers.
    
    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10
    double_the_difference([-1, -2, 0]) == 0
    double_the_difference([9, -2]) == 81
    double_the_difference([0]) == 0  
   
    If the input list is empty, return 0.
    '''
    return sum([i ** 2 for i in lst if i > 0 and i % 2 ! = 0 and "." not in str(i)])
DEDENT
</source>
<source file="./systems/Original_Files/153.py" startline="2" endline="30">
def Strongest_Extension(class_name, extensions) :
INDENT
    strong = extensions [0]
    my_val = len([x for x in extensions [0] if x.isalpha() and x.isupper()]) - len([x for x in extensions [0] if x.isalpha() and x.islower()])
    for s in extensions :
    INDENT
        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])
        if val > my_val :
        INDENT
            strong = s
            my_val = val
        DEDENT
    DEDENT
    ans = class_name + "." + strong
    return ans
DEDENT
</source>
<source file="./systems/Original_Files/27.py" startline="3" endline="9">
def flip_case(string : str) -> str :
INDENT
    return string.swapcase()
DEDENT
</source>
<source file="./systems/Original_Files/117.py" startline="2" endline="25">
def select_words(s, n) :
INDENT
    result = []
    for word in s.split() :
    INDENT
        n_consonants = 0
        for i in range(0, len(word)) :
        INDENT
            if word [i].lower() not in ["a", "e", "i", "o", "u"] :
            INDENT
                n_consonants += 1
            DEDENT
        DEDENT
        if n_consonants == n :
        INDENT
            result.append(word)
        DEDENT
    DEDENT
    return result
DEDENT
</source>
<source file="./systems/Original_Files/102.py" startline="2" endline="18">
def choose_num(x, y) :
INDENT
    if x > y :
    INDENT
        return - 1
    DEDENT
    if y % 2 == 0 :
    INDENT
        return y
    DEDENT
    if x == y :
    INDENT
        return - 1
    DEDENT
    return y - 1
DEDENT
</source>
<source file="./systems/Original_Files/38.py" startline="3" endline="13">
def encode_cyclic(s : str) :
INDENT
    groups = [s [(3 * i) : min((3 * i + 3), len(s))] for i in range((len(s) + 2) / / 3)]
    groups = [(group [1 :] + group [0]) if len(group) == 3 else group for group in groups]
    return "".join(groups)

DEDENT
</source>
<source file="./systems/Original_Files/38.py" startline="14" endline="19">
def decode_cyclic(s : str) :
INDENT
    return encode_cyclic(encode_cyclic(s))
DEDENT
</source>
<source file="./systems/Original_Files/33.py" startline="3" endline="15">
def sort_third(l : list) :
INDENT
    l = list(l)
    l [: : 3] = sorted(l [: : 3])
    return l
DEDENT
</source>
<source file="./systems/Original_Files/35.py" startline="3" endline="15">
def max_element(l : list) :
INDENT
    m = l [0]
    for e in l :
    INDENT
        if e > m :
        INDENT
            m = e
        DEDENT
    DEDENT
    return m
DEDENT
</source>
<source file="./systems/Original_Files/128.py" startline="2" endline="17">
def prod_signs(arr) :
INDENT
    if not arr : return None
    prod = 0 if 0 in arr else (- 1) ** len(list(filter(lambda x : x < 0, arr)))
    return prod * sum([abs(i) for i in arr])
DEDENT
</source>
<source file="./systems/Original_Files/161.py" startline="2" endline="27">
def solve(s) :
INDENT
    flg = 0
    idx = 0
    new_str = list(s)
    for i in s :
    INDENT
        if i.isalpha() :
        INDENT
            new_str [idx] = i.swapcase()
            flg = 1
        DEDENT
        idx += 1
    DEDENT
    s = ""
    for i in new_str :
    INDENT
        s += i
    DEDENT
    if flg == 0 :
    INDENT
        return s [len(s) : : - 1]
    DEDENT
    return s
DEDENT
</source>
<source file="./systems/Original_Files/90.py" startline="2" endline="15">
def next_smallest(lst) :
INDENT
    lst = sorted(set(lst))
    return None if len(lst) < 2 else lst [1]
DEDENT
</source>
<source file="./systems/Original_Files/147.py" startline="2" endline="24">
def get_max_triples(n) :
INDENT
    A = [i * i - i + 1 for i in range(1, n + 1)]
    ans = []
    for i in range(n) :
    INDENT
        for j in range(i + 1, n) :
        INDENT
            for k in range(j + 1, n) :
            INDENT
                if (A [i] + A [j] + A [k]) % 3 == 0 :
                INDENT
                    ans += [(A [i], A [j], A [k])]
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    return len(ans)
DEDENT
</source>
<source file="./systems/Original_Files/85.py" startline="2" endline="10">
def add(lst) :
INDENT
    return sum([lst [i] for i in range(1, len(lst), 2) if lst [i] % 2 == 0])
DEDENT
</source>
<source file="./systems/Original_Files/84.py" startline="2" endline="17">
def solve(N) :
INDENT
    return bin(sum(int(i) for i in str(N))) [2 :]
DEDENT
</source>
<source file="./systems/Original_Files/73.py" startline="2" endline="18">
def smallest_change(arr) :
INDENT
    ans = 0
    for i in range(len(arr) / / 2) :
    INDENT
        if arr [i] ! = arr [len(arr) - i - 1] :
        INDENT
            ans += 1
        DEDENT
    DEDENT
    return ans
DEDENT
</source>
<source file="./systems/Original_Files/45.py" startline="3" endline="9">
def triangle_area(a, h) :
INDENT
    return a * h / 2.0
DEDENT
</source>
<source file="./systems/Original_Files/77.py" startline="2" endline="17">
def iscube(a) :
INDENT
    '''
    Write a function that takes an integer a and returns True 
    if this ingeger is a cube of some integer number.
    Note: you may assume the input is always valid.
    Examples:
    iscube(1) ==> True
    iscube(2) ==> False
    iscube(-1) ==> True
    iscube(64) ==> True
    iscube(0) ==> True
    iscube(180) ==> False
    '''
    a = abs(a)
    return int(round(a ** (1./ 3))) ** 3 == a
DEDENT
</source>
<source file="./systems/Original_Files/100.py" startline="2" endline="17">
def make_a_pile(n) :
INDENT
    return [n + 2 * i for i in range(n)]
DEDENT
</source>
<source file="./systems/Original_Files/81.py" startline="2" endline="58">
def numerical_letter_grade(grades) :
INDENT
    letter_grade = []
    for gpa in grades :
    INDENT
        if gpa == 4.0 :
        INDENT
            letter_grade.append("A+")
        DEDENT
        elif gpa > 3.7 :
        INDENT
            letter_grade.append("A")
        DEDENT
        elif gpa > 3.3 :
        INDENT
            letter_grade.append("A-")
        DEDENT
        elif gpa > 3.0 :
        INDENT
            letter_grade.append("B+")
        DEDENT
        elif gpa > 2.7 :
        INDENT
            letter_grade.append("B")
        DEDENT
        elif gpa > 2.3 :
        INDENT
            letter_grade.append("B-")
        DEDENT
        elif gpa > 2.0 :
        INDENT
            letter_grade.append("C+")
        DEDENT
        elif gpa > 1.7 :
        INDENT
            letter_grade.append("C")
        DEDENT
        elif gpa > 1.3 :
        INDENT
            letter_grade.append("C-")
        DEDENT
        elif gpa > 1.0 :
        INDENT
            letter_grade.append("D+")
        DEDENT
        elif gpa > 0.7 :
        INDENT
            letter_grade.append("D")
        DEDENT
        elif gpa > 0.0 :
        INDENT
            letter_grade.append("D-")
        DEDENT
        else :
        INDENT
            letter_grade.append("E")
        DEDENT
    DEDENT
    return letter_grade
DEDENT
</source>
<source file="./systems/Original_Files/140.py" startline="2" endline="33">
def fix_spaces(text) :
INDENT
    new_text = ""
    i = 0
    start, end = 0, 0
    while i < len(text) :
    INDENT
        if text [i] == " " :
        INDENT
            end += 1
        DEDENT
        else :
        INDENT
            if end - start > 2 :
            INDENT
                new_text += "-" + text [i]
            DEDENT
            elif end - start > 0 :
            INDENT
                new_text += "_" * (end - start) + text [i]
            DEDENT
            else :
            INDENT
                new_text += text [i]
            DEDENT
            start, end = i + 1, i + 1
        DEDENT
        i += 1
    DEDENT
    if end - start > 2 :
    INDENT
        new_text += "-"
    DEDENT
    elif end - start > 0 :
    INDENT
        new_text += "_"
    DEDENT
    return new_text
DEDENT
</source>
<source file="./systems/Original_Files/94.py" startline="3" endline="30">
def skjkasdkd(lst) :
INDENT
    def isPrime(n) :
    INDENT
        for i in range(2, int(n ** 0.5) + 1) :
        INDENT
            if n % i == 0 :
            INDENT
                return False
            DEDENT
        DEDENT
        return True
    DEDENT
    maxx = 0
    i = 0
    while i < len(lst) :
    INDENT
        if (lst [i] > maxx and isPrime(lst [i])) :
        INDENT
            maxx = lst [i]
        DEDENT
        i += 1
    DEDENT
    result = sum(int(digit) for digit in str(maxx))
    return result
DEDENT
</source>
<source file="./systems/Original_Files/94.py" startline="16" endline="21">
def isPrime(n) :
INDENT
    for i in range(2, int(n ** 0.5) + 1) :
    INDENT
        if n % i == 0 :
        INDENT
            return False
        DEDENT
    DEDENT
    return True
DEDENT
</source>
<source file="./systems/Original_Files/97.py" startline="2" endline="13">
def multiply(a, b) :
INDENT
    return abs(a % 10) * abs(b % 10)
DEDENT
</source>
<source file="./systems/Original_Files/135.py" startline="2" endline="19">
def can_arrange(arr) :
INDENT
    ind = - 1
    i = 1
    while i < len(arr) :
    INDENT
        if arr [i] < arr [i - 1] :
        INDENT
            ind = i
        DEDENT
        i += 1
    DEDENT
    return ind
DEDENT
</source>
<source file="./systems/Original_Files/14.py" startline="4" endline="14">
def all_prefixes(string : str) -> List [str] :
INDENT
    result = []
    for i in range(len(string)) :
    INDENT
        result.append(string [: i + 1])
    DEDENT
    return result
DEDENT
</source>
<source file="./systems/Original_Files/131.py" startline="2" endline="21">
def digits(n) :
INDENT
    product = 1
    odd_count = 0
    for digit in str(n) :
    INDENT
        int_digit = int(digit)
        if int_digit % 2 == 1 :
        INDENT
            product = product * int_digit
            odd_count += 1
        DEDENT
    DEDENT
    if odd_count == 0 :
    INDENT
        return 0
    DEDENT
    else :
    INDENT
        return product
    DEDENT
DEDENT
</source>
<source file="./systems/Original_Files/154.py" startline="2" endline="19">
def cycpattern_check(a, b) :
INDENT
    l = len(b)
    pat = b + b
    for i in range(len(a) - l + 1) :
    INDENT
        for j in range(l + 1) :
        INDENT
            if a [i : i + l] == pat [j : j + l] :
            INDENT
                return True
            DEDENT
        DEDENT
    DEDENT
    return False
DEDENT
</source>
<source file="./systems/Original_Files/16.py" startline="3" endline="11">
def count_distinct_characters(string : str) -> int :
INDENT
    return len(set(string.lower()))
DEDENT
</source>
<source file="./systems/Original_Files/136.py" startline="2" endline="17">
def largest_smallest_integers(lst) :
INDENT
    '''
    Create a function that returns a tuple (a, b), where 'a' is
    the largest of negative integers, and 'b' is the smallest
    of positive integers in a list.
    If there is no negative or positive integers, return them as None.

    Examples:
    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)
    largest_smallest_integers([]) == (None, None)
    largest_smallest_integers([0]) == (None, None)
    '''
    smallest = list(filter(lambda x : x < 0, lst))
    largest = list(filter(lambda x : x > 0, lst))
    return (max(smallest) if smallest else None, min(largest) if largest else None)
DEDENT
</source>
<source file="./systems/Original_Files/19.py" startline="4" endline="24">
def sort_numbers(numbers : str) -> str :
INDENT
    value_map = {
        'zero' : 0,
        'one' : 1,
        'two' : 2,
        'three' : 3,
        'four' : 4,
        'five' : 5,
        'six' : 6,
        'seven' : 7,
        'eight' : 8,
        'nine' : 9}
    return ' '.join(sorted([x for x in numbers.split(' ') if x], key = lambda x : value_map [x]))
DEDENT
</source>
<source file="./systems/Original_Files/12.py" startline="4" endline="21">
def longest(strings : List [str]) -> Optional [str] :
INDENT
    if not strings :
    INDENT
        return None
    DEDENT
    maxlen = max(len(x) for x in strings)
    for s in strings :
    INDENT
        if len(s) == maxlen :
        INDENT
            return s
        DEDENT
    DEDENT
DEDENT
</source>
<source file="./systems/Original_Files/71.py" startline="2" endline="19">
def triangle_area(a, b, c) :
INDENT
    '''
    Given the lengths of the three sides of a triangle. Return the area of
    the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
    Otherwise return -1
    Three sides make a valid triangle when the sum of any two sides is greater 
    than the third side.
    Example:
    triangle_area(3, 4, 5) == 6.00
    triangle_area(1, 2, 10) == -1
    '''
    if a + b < = c or a + c < = b or b + c < = a :
    INDENT
        return - 1
    DEDENT
    s = (a + b + c) / 2
    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
    area = round(area, 2)
    return area
DEDENT
</source>
<source file="./systems/Original_Files/104.py" startline="2" endline="19">
def unique_digits(x) :
INDENT
    odd_digit_elements = []
    for i in x :
    INDENT
        if all(int(c) % 2 == 1 for c in str(i)) :
        INDENT
            odd_digit_elements.append(i)
        DEDENT
    DEDENT
    return sorted(odd_digit_elements)
DEDENT
</source>
<source file="./systems/Original_Files/36.py" startline="3" endline="21">
def fizz_buzz(n : int) :
INDENT
    ns = []
    for i in range(n) :
    INDENT
        if i % 11 == 0 or i % 13 == 0 :
        INDENT
            ns.append(i)
        DEDENT
    DEDENT
    s = ''.join(list(map(str, ns)))
    ans = 0
    for c in s :
    INDENT
        ans += (c == '7')
    DEDENT
    return ans
DEDENT
</source>
<source file="./systems/Original_Files/89.py" startline="2" endline="21">
def encrypt(s) :
INDENT
    d = 'abcdefghijklmnopqrstuvwxyz'
    out = ''
    for c in s :
    INDENT
        if c in d :
        INDENT
            out += d [(d.index(c) + 2 * 2) % 26]
        DEDENT
        else :
        INDENT
            out += c
        DEDENT
    DEDENT
    return out
DEDENT
</source>
<source file="./systems/Original_Files/1.py" startline="4" endline="29">
def separate_paren_groups(paren_string : str) -> List [str] :
INDENT
    result = []
    current_string = []
    current_depth = 0
    for c in paren_string :
    INDENT
        if c == '(' :
        INDENT
            current_depth += 1
            current_string.append(c)
        DEDENT
        elif c == ')' :
        INDENT
            current_depth -= 1
            current_string.append(c)
            if current_depth == 0 :
            INDENT
                result.append(''.join(current_string))
                current_string.clear()
            DEDENT
        DEDENT
    DEDENT
    return result
DEDENT
</source>
<source file="./systems/Original_Files/18.py" startline="3" endline="19">
def how_many_times(string : str, substring : str) -> int :
INDENT
    times = 0
    for i in range(len(string) - len(substring) + 1) :
    INDENT
        if string [i : i + len(substring)] == substring :
        INDENT
            times += 1
        DEDENT
    DEDENT
    return times
DEDENT
</source>
<source file="./systems/Original_Files/13.py" startline="3" endline="13">
def greatest_common_divisor(a : int, b : int) -> int :
INDENT
    while b :
    INDENT
        a, b = b, a % b
    DEDENT
    return a
DEDENT
</source>
<source file="./systems/Original_Files/28.py" startline="4" endline="12">
def concatenate(strings : List [str]) -> str :
INDENT
    return ''.join(strings)
DEDENT
</source>
<source file="./systems/Original_Files/149.py" startline="2" endline="23">
def sorted_list_sum(lst) :
INDENT
    lst.sort()
    new_lst = []
    for i in lst :
    INDENT
        if len(i) % 2 == 0 :
        INDENT
            new_lst.append(i)
        DEDENT
    DEDENT
    return sorted(new_lst, key = len)
DEDENT
</source>
<source file="./systems/Original_Files/4.py" startline="4" endline="15">
def mean_absolute_deviation(numbers : List [float]) -> float :
INDENT
    mean = sum(numbers) / len(numbers)
    return sum(abs(x - mean) for x in numbers) / len(numbers)
DEDENT
</source>
<source file="./systems/Original_Files/134.py" startline="2" endline="18">
def check_if_last_char_is_a_letter(txt) :
INDENT
    '''
    Create a function that returns True if the last character
    of a given string is an alphabetical character and is not
    a part of a word, and False otherwise.
    Note: "word" is a group of characters separated by space.

    Examples:
    check_if_last_char_is_a_letter("apple pie") ➞ False
    check_if_last_char_is_a_letter("apple pi e") ➞ True
    check_if_last_char_is_a_letter("apple pi e ") ➞ False
    check_if_last_char_is_a_letter("") ➞ False 
    '''

    check = txt.split(' ') [- 1]
    return True if len(check) == 1 and (97 < = ord(check.lower()) < = 122) else False
DEDENT
</source>
<source file="./systems/Original_Files/76.py" startline="2" endline="20">
def is_simple_power(x, n) :
INDENT
    if (n == 1) :
    INDENT
        return (x == 1)
    DEDENT
    power = 1
    while (power < x) :
    INDENT
        power = power * n
    DEDENT
    return (power == x)
DEDENT
</source>
<source file="./systems/Original_Files/115.py" startline="2" endline="38">
def max_fill(grid, capacity) :
INDENT
    import math
    """
    You are given a rectangular grid of wells. Each row represents a single well,
    and each 1 in a row represents a single unit of water.
    Each well has a corresponding bucket that can be used to extract water from it, 
    and all buckets have the same capacity.
    Your task is to use the buckets to empty the wells.
    Output the number of times you need to lower the buckets.

    Example 1:
        Input: 
            grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]
            bucket_capacity : 1
        Output: 6

    Example 2:
        Input: 
            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]
            bucket_capacity : 2
        Output: 5
    
    Example 3:
        Input: 
            grid : [[0,0,0], [0,0,0]]
            bucket_capacity : 5
        Output: 0

    Constraints:
        * all wells have the same length
        * 1 <= grid.length <= 10^2
        * 1 <= grid[:,1].length <= 10^2
        * grid[i][j] -> 0 | 1
        * 1 <= capacity <= 10
    """
    return sum([math.ceil(sum(arr) / capacity) for arr in grid])
DEDENT
</source>
<source file="./systems/Original_Files/124.py" startline="2" endline="38">
def valid_date(date) :
INDENT
    try :
    INDENT
        date = date.strip()
        month, day, year = date.split('-')
        month, day, year = int(month), int(day), int(year)
        if month < 1 or month > 12 :
        INDENT
            return False
        DEDENT
        if month in [1, 3, 5, 7, 8, 10, 12] and day < 1 or day > 31 :
        INDENT
            return False
        DEDENT
        if month in [4, 6, 9, 11] and day < 1 or day > 30 :
        INDENT
            return False
        DEDENT
        if month == 2 and day < 1 or day > 29 :
        INDENT
            return False
        DEDENT
    DEDENT
    except :
    INDENT
        return False
    DEDENT
    return True
DEDENT
</source>
<source file="./systems/Original_Files/43.py" startline="3" endline="24">
def pairs_sum_to_zero(l) :
INDENT
    for i, l1 in enumerate(l) :
    INDENT
        for j in range(i + 1, len(l)) :
        INDENT
            if l1 + l [j] == 0 :
            INDENT
                return True
            DEDENT
        DEDENT
    DEDENT
    return False
DEDENT
</source>
<source file="./systems/Original_Files/99.py" startline="2" endline="40">
def closest_integer(value) :
INDENT
    '''
    Create a function that takes a value (string) representing a number
    and returns the closest integer to it. If the number is equidistant
    from two integers, round it away from zero.

    Examples
    >>> closest_integer("10")
    10
    >>> closest_integer("15.3")
    15

    Note:
    Rounding away from zero means that if the given number is equidistant
    from two integers, the one you should return is the one that is the
    farthest from zero. For example closest_integer("14.5") should
    return 15 and closest_integer("-14.5") should return -15.
    '''
    from math import floor, ceil
    if value.count('.') == 1 :
    INDENT
        while (value [- 1] == '0') :
        INDENT
            value = value [: - 1]
        DEDENT
    DEDENT
    num = float(value)
    if value [- 2 :] == '.5' :
    INDENT
        if num > 0 :
        INDENT
            res = ceil(num)
        DEDENT
        else :
        INDENT
            res = floor(num)
        DEDENT
    DEDENT
    elif len(value) > 0 :
    INDENT
        res = int(round(num))
    DEDENT
    else :
    INDENT
        res = 0
    DEDENT
    return res
DEDENT
</source>
<source file="./systems/Original_Files/23.py" startline="3" endline="11">
def strlen(string : str) -> int :
INDENT
    return len(string)
DEDENT
</source>
<source file="./systems/Original_Files/96.py" startline="2" endline="24">
def count_up_to(n) :
INDENT
    primes = []
    for i in range(2, n) :
    INDENT
        is_prime = True
        for j in range(2, i) :
        INDENT
            if i % j == 0 :
            INDENT
                is_prime = False
                break
            DEDENT
        DEDENT
        if is_prime :
        INDENT
            primes.append(i)
        DEDENT
    DEDENT
    return primes
DEDENT
</source>
<source file="./systems/Original_Files/152.py" startline="2" endline="18">
def compare(game, guess) :
INDENT
    return [abs(x - y) for x, y in zip(game, guess)]
DEDENT
</source>
<source file="./systems/Original_Files/129.py" startline="2" endline="59">
def minPath(grid, k) :
INDENT
    n = len(grid)
    val = n * n + 1
    for i in range(n) :
    INDENT
        for j in range(n) :
        INDENT
            if grid [i] [j] == 1 :
            INDENT
                temp = []
                if i ! = 0 :
                INDENT
                    temp.append(grid [i - 1] [j])
                DEDENT
                if j ! = 0 :
                INDENT
                    temp.append(grid [i] [j - 1])
                DEDENT
                if i ! = n - 1 :
                INDENT
                    temp.append(grid [i + 1] [j])
                DEDENT
                if j ! = n - 1 :
                INDENT
                    temp.append(grid [i] [j + 1])
                DEDENT
                val = min(temp)
            DEDENT
        DEDENT
    DEDENT
    ans = []
    for i in range(k) :
    INDENT
        if i % 2 == 0 :
        INDENT
            ans.append(1)
        DEDENT
        else :
        INDENT
            ans.append(val)
        DEDENT
    DEDENT
    return ans
DEDENT
</source>
<source file="./systems/Original_Files/144.py" startline="2" endline="21">
def simplify(x, n) :
INDENT
    a, b = x.split("/")
    c, d = n.split("/")
    numerator = int(a) * int(c)
    denom = int(b) * int(d)
    if (numerator / denom == int(numerator / denom)) :
    INDENT
        return True
    DEDENT
    return False
DEDENT
</source>
<source file="./systems/Original_Files/141.py" startline="2" endline="30">
def file_name_check(file_name) :
INDENT
    suf = ['txt', 'exe', 'dll']
    lst = file_name.split(sep = '.')
    if len(lst) ! = 2 :
    INDENT
        return 'No'
    DEDENT
    if not lst [1] in suf :
    INDENT
        return 'No'
    DEDENT
    if len(lst [0]) == 0 :
    INDENT
        return 'No'
    DEDENT
    if not lst [0] [0].isalpha() :
    INDENT
        return 'No'
    DEDENT
    t = len([x for x in lst [0] if x.isdigit()])
    if t > 3 :
    INDENT
        return 'No'
    DEDENT
    return 'Yes'
DEDENT
</source>
<source file="./systems/Original_Files/67.py" startline="2" endline="20">
def fruit_distribution(s, n) :
INDENT
    lis = list()
    for i in s.split(' ') :
    INDENT
        if i.isdigit() :
        INDENT
            lis.append(int(i))
        DEDENT
    DEDENT
    return n - sum(lis)
DEDENT
</source>
<source file="./systems/Original_Files/46.py" startline="3" endline="27">
def fib4(n : int) :
INDENT
    results = [0, 0, 2, 0]
    if n < 4 :
    INDENT
        return results [n]
    DEDENT
    for _ in range(4, n + 1) :
    INDENT
        results.append(results [- 1] + results [- 2] + results [- 3] + results [- 4])
        results.pop(0)
    DEDENT
    return results [- 1]
DEDENT
</source>
<source file="./systems/Original_Files/103.py" startline="2" endline="19">
def rounded_avg(n, m) :
INDENT
    if m < n :
    INDENT
        return - 1
    DEDENT
    summation = 0
    for i in range(n, m + 1) :
    INDENT
        summation += i
    DEDENT
    return bin(round(summation / (m - n + 1)))
DEDENT
</source>
<source file="./systems/Original_Files/75.py" startline="2" endline="24">
def is_multiply_prime(a) :
INDENT
    def is_prime(n) :
    INDENT
        for j in range(2, n) :
        INDENT
            if n % j == 0 :
            INDENT
                return False
            DEDENT
        DEDENT
        return True
    DEDENT
    for i in range(2, 101) :
    INDENT
        if not is_prime(i) : continue
        for j in range(2, 101) :
        INDENT
            if not is_prime(j) : continue
            for k in range(2, 101) :
            INDENT
                if not is_prime(k) : continue
                if i * j * k == a : return True
            DEDENT
        DEDENT
    DEDENT
    return False
DEDENT
</source>
<source file="./systems/Original_Files/75.py" startline="11" endline="16">
def is_prime(n) :
INDENT
    for j in range(2, n) :
    INDENT
        if n % j == 0 :
        INDENT
            return False
        DEDENT
    DEDENT
    return True
DEDENT
</source>
<source file="./systems/Original_Files/139.py" startline="2" endline="20">
def special_factorial(n) :
INDENT
    fact_i = 1
    special_fact = 1
    for i in range(1, n + 1) :
    INDENT
        fact_i *= i
        special_fact *= fact_i
    DEDENT
    return special_fact
DEDENT
</source>
<source file="./systems/Original_Files/160.py" startline="2" endline="31">
def do_algebra(operator, operand) :
INDENT
    expression = str(operand [0])
    for oprt, oprn in zip(operator, operand [1 :]) :
    INDENT
        expression += oprt + str(oprn)
    DEDENT
    return eval(expression)
DEDENT
</source>
<source file="./systems/Original_Files/138.py" startline="2" endline="10">
def is_equal_to_sum_even(n) :
INDENT
    return n % 2 == 0 and n > = 8
DEDENT
</source>
<source file="./systems/Original_Files/92.py" startline="2" endline="26">
def any_int(x, y, z) :
INDENT
    '''
    Create a function that takes 3 numbers.
    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.
    Returns false in any other cases.
    
    Examples
    any_int(5, 2, 7) ➞ True
    
    any_int(3, 2, 2) ➞ False

    any_int(3, -2, 1) ➞ True
    
    any_int(3.6, -2.2, 2) ➞ False
  

    
    '''

    if isinstance(x, int) and isinstance(y, int) and isinstance(z, int) :
    INDENT
        if (x + y == z) or (x + z == y) or (y + z == x) :
        INDENT
            return True
        DEDENT
        return False
    DEDENT
    return False
DEDENT
</source>
<source file="./systems/Original_Files/22.py" startline="4" endline="12">
def filter_integers(values : List [Any]) -> List [int] :
INDENT
    return [x for x in values if isinstance(x, int)]
DEDENT
</source>
<source file="./systems/Original_Files/91.py" startline="2" endline="17">
def is_bored(S) :
INDENT
    import re
    sentences = re.split(r'[.?!]\s*', S)
    return sum(sentence [0 : 2] == 'I ' for sentence in sentences)
DEDENT
</source>
<source file="./systems/Original_Files/66.py" startline="2" endline="17">
def digitSum(s) :
INDENT
    if s == "" : return 0
    return sum(ord(char) if char.isupper() else 0 for char in s)
DEDENT
</source>
<source file="./systems/Original_Files/32.py" startline="4" endline="11">
def poly(xs : list, x : float) :
INDENT
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])

DEDENT
</source>
<source file="./systems/Original_Files/32.py" startline="12" endline="35">
def find_zero(xs : list) :
INDENT
    begin, end = - 1., 1.
    while poly(xs, begin) * poly(xs, end) > 0 :
    INDENT
        begin *= 2.0
        end *= 2.0
    DEDENT
    while end - begin > 1e-10 :
    INDENT
        center = (begin + end) / 2.0
        if poly(xs, center) * poly(xs, begin) > 0 :
        INDENT
            begin = center
        DEDENT
        else :
        INDENT
            end = center
        DEDENT
    DEDENT
    return begin
DEDENT
</source>
<source file="./systems/Original_Files/137.py" startline="2" endline="19">
def compare_one(a, b) :
INDENT
    temp_a, temp_b = a, b
    if isinstance(temp_a, str) : temp_a = temp_a.replace(',', '.')
    if isinstance(temp_b, str) : temp_b = temp_b.replace(',', '.')
    if float(temp_a) == float(temp_b) : return None
    return a if float(temp_a) > float(temp_b) else b
DEDENT
</source>
<source file="./systems/Original_Files/105.py" startline="2" endline="43">
def by_length(arr) :
INDENT
    dic = {
        1 : "One",
        2 : "Two",
        3 : "Three",
        4 : "Four",
        5 : "Five",
        6 : "Six",
        7 : "Seven",
        8 : "Eight",
        9 : "Nine",
        }
    sorted_arr = sorted(arr, reverse = True)
    new_arr = []
    for var in sorted_arr :
    INDENT
        try :
        INDENT
            new_arr.append(dic [var])
        DEDENT
        except :
        INDENT
            pass
        DEDENT
    DEDENT
    return new_arr
DEDENT
</source>
<source file="./systems/Original_Files/68.py" startline="2" endline="40">
def pluck(arr) :
INDENT
    if (len(arr) == 0) : return []
    evens = list(filter(lambda x : x % 2 == 0, arr))
    if (evens == []) : return []
    return [min(evens), arr.index(min(evens))]
DEDENT
</source>
<source file="./systems/Original_Files/113.py" startline="2" endline="19">
def odd_count(lst) :
INDENT
    res = []
    for arr in lst :
    INDENT
        n = sum(int(d) % 2 == 1 for d in arr)
        res.append("the number of odd elements " + str(n) + "n the str" + str(n) + "ng " + str(n) + " of the " + str(n) + "nput.")
    DEDENT
    return res
DEDENT
</source>
<source file="./systems/Original_Files/116.py" startline="2" endline="14">
def sort_array(arr) :
INDENT
    return sorted(sorted(arr), key = lambda x : bin(x) [2 :].count('1'))
DEDENT
</source>
<source file="./systems/Original_Files/120.py" startline="2" endline="32">
def maximum(arr, k) :
INDENT
    if k == 0 :
    INDENT
        return []
    DEDENT
    arr.sort()
    ans = arr [- k :]
    return ans
DEDENT
</source>
<source file="./systems/Original_Files/130.py" startline="2" endline="28">
def tri(n) :
INDENT
    if n == 0 :
    INDENT
        return [1]
    DEDENT
    my_tri = [1, 3]
    for i in range(2, n + 1) :
    INDENT
        if i % 2 == 0 :
        INDENT
            my_tri.append(i / 2 + 1)
        DEDENT
        else :
        INDENT
            my_tri.append(my_tri [i - 1] + my_tri [i - 2] + (i + 3) / 2)
        DEDENT
    DEDENT
    return my_tri
DEDENT
</source>
<source file="./systems/Original_Files/106.py" startline="2" endline="22">
def f(n) :
INDENT
    ret = []
    for i in range(1, n + 1) :
    INDENT
        if i % 2 == 0 :
        INDENT
            x = 1
            for j in range(1, i + 1) : x *= j
            ret += [x]
        DEDENT
        else :
        INDENT
            x = 0
            for j in range(1, i + 1) : x += j
            ret += [x]
        DEDENT
    DEDENT
    return ret
DEDENT
</source>
<source file="./systems/Original_Files/48.py" startline="3" endline="19">
def is_palindrome(text : str) :
INDENT
    for i in range(len(text)) :
    INDENT
        if text [i] ! = text [len(text) - 1 - i] :
        INDENT
            return False
        DEDENT
    DEDENT
    return True
DEDENT
</source>
<source file="./systems/Original_Files/26.py" startline="4" endline="13">
def remove_duplicates(numbers : List [int]) -> List [int] :
INDENT
    import collections
    c = collections.Counter(numbers)
    return [n for n in numbers if c [n] < = 1]
DEDENT
</source>
