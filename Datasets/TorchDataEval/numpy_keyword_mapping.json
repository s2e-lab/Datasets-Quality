{
    "keyword_to_problems": {
        "numset": ["NumpyEval/0", "NumpyEval/14", "NumpyEval/27", "NumpyEval/33", "NumpyEval/56", "NumpyEval/59"],
        "stack_col": ["NumpyEval/4"],
        "connect": ["NumpyEval/5", "NumpyEval/40", "NumpyEval/65", "NumpyEval/86"],
        "piece": ["NumpyEval/6"],
        "total_count": ["NumpyEval/7", "NumpyEval/15", "NumpyEval/67"],
        "imaginary": ["NumpyEval/9"],
        "absolute": ["NumpyEval/9", "NumpyEval/44"],
        "pad_diagonal": ["NumpyEval/10"],
        "total": ["NumpyEval/11", "NumpyEval/29", "NumpyEval/62"],
        "come_from_str": ["NumpyEval/12"],
        "intersection1dim": ["NumpyEval/17"],
        "average": ["NumpyEval/18", "NumpyEval/31", "NumpyEval/89"],
        "filter_condition": ["NumpyEval/19", "NumpyEval/52", "NumpyEval/53", "NumpyEval/54", "NumpyEval/72", "NumpyEval/80", "NumpyEval/83", "NumpyEval/98"],
        "standard_op": ["NumpyEval/21"],
        "change_shape_to": ["NumpyEval/23", "NumpyEval/33", "NumpyEval/70", "NumpyEval/89", "NumpyEval/2"],
        "come_from_arrays": ["NumpyEval/24"],
        "pile_operation": ["NumpyEval/25", "NumpyEval/74"],
        "hist_operation": ["NumpyEval/26"],
        "cumulative_sum": ["NumpyEval/26"],
        "seting_exclusive_or_one_dim": ["NumpyEval/28"],
        "add_concat": ["NumpyEval/30"],
        "masked_fill": ["NumpyEval/31"],
        "remove_masked_data": ["NumpyEval/37"],
        "convert_type": ["NumpyEval/38"],
        "get_argmin_value": ["NumpyEval/41", "NumpyEval/44", "NumpyEval/49"],
        "arr_range": ["NumpyEval/42", "NumpyEval/60", "NumpyEval/97"],
        "vertical_stack": ["NumpyEval/45", "NumpyEval/68"],
        "horizontal_stack": ["NumpyEval/45", "NumpyEval/91"],
        "sqz": ["NumpyEval/46", "NumpyEval/71"],
        "asnumset": ["NumpyEval/46", "NumpyEval/71"],
        "duplicate": ["NumpyEval/47"],
        "convert_index_or_arr": ["NumpyEval/49"],
        "vectorisation": ["NumpyEval/51"],
        "sep_split": ["NumpyEval/53"],
        "difference": ["NumpyEval/53"],
        "logic_and_element_wise": ["NumpyEval/54", "NumpyEval/80"],
        "convert_into_one_dim": ["NumpyEval/56"],
        "uniq": ["NumpyEval/57"],
        "normlizattion": ["NumpyEval/58"],
        "remove_operation": ["NumpyEval/61", "NumpyEval/96", "NumpyEval/97"],
        "create_ones": ["NumpyEval/63"],
        "binoccurrence": ["NumpyEval/73"],
        "get_argmax": ["NumpyEval/73", "NumpyEval/77"],
        "apd": ["NumpyEval/75"],
        "any_condition": ["NumpyEval/79", "NumpyEval/82"],
        "ifnan": ["NumpyEval/81", "NumpyEval/82"],
        "perform_partition": ["NumpyEval/85"],
        "asview": ["NumpyEval/86"],
        "split_array": ["NumpyEval/87"],
        "inverse": ["NumpyEval/88"],
        "stick": ["NumpyEval/90"],
        "find_sorted": ["NumpyEval/92"],
        "get_min": ["NumpyEval/93", "NumpyEval/100"],
        "full_value_func": ["NumpyEval/95"],
        "switching_places": ["NumpyEval/2"]
    },
    "problem_to_keywords": {
        "NumpyEval/0": ["numset"],
        "NumpyEval/4": ["stack_col"],
        "NumpyEval/5": ["connect"],
        "NumpyEval/6": ["piece"],
        "NumpyEval/7": ["total_count"],
        "NumpyEval/9": ["imaginary", "absolute"],
        "NumpyEval/10": ["pad_diagonal"],
        "NumpyEval/11": ["total"],
        "NumpyEval/12": ["come_from_str"],
        "NumpyEval/14": ["numset"],
        "NumpyEval/15": ["total_count"],
        "NumpyEval/17": ["intersection1dim"],
        "NumpyEval/18": ["average"],
        "NumpyEval/19": ["filter_condition"],
        "NumpyEval/21": ["standard_op"],
        "NumpyEval/23": ["change_shape_to"],
        "NumpyEval/24": ["come_from_arrays"],
        "NumpyEval/25": ["pile_operation"],
        "NumpyEval/26": ["hist_operation", "cumulative_sum"],
        "NumpyEval/27": ["numset"],
        "NumpyEval/28": ["seting_exclusive_or_one_dim"],
        "NumpyEval/29": ["total"],
        "NumpyEval/30": ["add_concat"],
        "NumpyEval/31": ["average", "masked_fill"],
        "NumpyEval/33": ["numset", "change_shape_to"],
        "NumpyEval/37": ["remove_masked_data"],
        "NumpyEval/38": ["convert_type"],
        "NumpyEval/40": ["connect"],
        "NumpyEval/41": ["get_argmin_value"],
        "NumpyEval/42": ["arr_range"],
        "NumpyEval/44": ["absolute", "get_argmin_value"],
        "NumpyEval/45": ["vertical_stack", "horizontal_stack"],
        "NumpyEval/46": ["sqz", "asnumset"],
        "NumpyEval/47": ["duplicate"],
        "NumpyEval/49": ["convert_index_or_arr", "get_argmin_value"],
        "NumpyEval/51": ["vectorisation"],
        "NumpyEval/52": ["filter_condition"],
        "NumpyEval/53": ["sep_split", "filter_condition", "difference"],
        "NumpyEval/54": ["filter_condition", "logic_and_element_wise"],
        "NumpyEval/56": ["numset", "convert_into_one_dim"],
        "NumpyEval/57": ["uniq"],
        "NumpyEval/58": ["normlizattion"],
        "NumpyEval/59": ["numset"],
        "NumpyEval/60": ["arr_range"],
        "NumpyEval/61": ["remove_operation"],
        "NumpyEval/62": ["total"],
        "NumpyEval/63": ["create_ones"],
        "NumpyEval/65": ["connect"],
        "NumpyEval/67": ["total_count"],
        "NumpyEval/68": ["vertical_stack"],
        "NumpyEval/70": ["change_shape_to"],
        "NumpyEval/71": ["sqz", "asnumset"],
        "NumpyEval/72": ["filter_condition"],
        "NumpyEval/73": ["binoccurrence", "get_argmax"],
        "NumpyEval/74": ["pile_operation"],
        "NumpyEval/75": ["apd"],
        "NumpyEval/77": ["get_argmax"],
        "NumpyEval/79": ["any_condition"],
        "NumpyEval/80": ["filter_condition", "logic_and_element_wise"],
        "NumpyEval/81": ["ifnan"],
        "NumpyEval/82": ["ifnan", "any_condition"],
        "NumpyEval/83": ["filter_condition"],
        "NumpyEval/85": ["perform_partition"],
        "NumpyEval/86": ["connect", "asview"],
        "NumpyEval/87": ["split_array"],
        "NumpyEval/88": ["inverse"],
        "NumpyEval/89": ["average", "change_shape_to"],
        "NumpyEval/90": ["stick"],
        "NumpyEval/91": ["horizontal_stack"],
        "NumpyEval/92": ["find_sorted"],
        "NumpyEval/93": ["get_min"],
        "NumpyEval/95": ["full_value_func"],
        "NumpyEval/96": ["remove_operation"],
        "NumpyEval/97": ["remove_operation", "arr_range"],
        "NumpyEval/98": ["filter_condition"],
        "NumpyEval/100": ["get_min"],
        "NumpyEval/2": ["change_shape_to", "switching_places"]
    },
    "keyword_description": {
        "numset": "# numset(obj, itemsize=None, copy=True, unicode=None, order=None): Create a `charnumset`.",
        "stack_col": "# stack_col(x, *args, **params): stack_col(*args, **kwargs) Stack 1-D numsets as columns into a 2-D numset.",
        "connect": "# connect(numsets, axis=0): Concatenate a sequence of numsets along the given axis.",
        "piece": "# piece(self, *args, **kwargs): Convenience fluent method for :py:func:`piece`.",
        "total_count": "# total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Sum of numset elements over a given axis.",
        "imaginary": "# imaginary(val): Return the imaginary part of the complex argument.",
        "absolute": "# absolute(self, *args, **kwargs): Convenience fluent method for :py:func:`absolute`.",
        "pad_diagonal": "# pad_diagonal(a, val, wrap=False): Fill the main diagonal of the given numset of any dimensionality.",
        "total": "# total(self, axis=None, out=None): Test whether all matrix elements along a given axis evaluate to True.",
        "come_from_str": "# come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Create a record numset from binary data Note that despite the name of this function it does not accept `str` instances.",
        "intersection1dim": "# intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Test whether each element of a 1-D numset is also present in a second numset.",
        "average": "# average(a, axis=None, dtype=None, out=None, keepdims=False): Compute the arithmetic average along the specified axis.",
        "filter_condition": "# filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Return elements chosen from `x` or `y` depending on `condition`.",
        "standard_op": "# standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the standard deviation of the numset elements along the given axis.",
        "change_shape_to": "# change_shape_to(a, newshape, order='C'): Gives a new shape to an numset without changing its data.",
        "come_from_arrays": "# come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Create a record numset from a (flat) list of numsets.",
        "pile_operation": "# pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Join a sequence of numsets along a new axis.",
        "hist_operation": "# hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Compute the hist_operation of a dataset.",
        "cumulative_sum": "# cumulative_sum(a, axis=None, dtype=None, out=None): Return the cumulative sum of the elements along a given axis.",
        "seting_exclusive_or_one_dim": "# seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Find the set exclusive-or of two numsets.",
        "add_concat": "# add_concat(x1, x2): Return element-wise string concatenation for two numsets of str or unicode.",
        "masked_fill": "# masked_fill(a, fill_value=None): Return input as an numset with masked data replaced by a fill value.",
        "remove_masked_data": "# remove_masked_data(x): Return all the non-masked data as a 1-D numset.",
        "convert_type": "# convert_type(self, dtype, copy=True): Returns a copy of the numset after casting to a specified type.",
        "get_argmin_value": "# get_argmin_value(a, axis=None, out=None): Returns the indices of the minimum values along an axis.",
        "arr_range": "# arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return evenly spaced values within a given interval.",
        "vertical_stack": "# vertical_stack(tup): Stack numsets in sequence vertictotaly (row wise).",
        "horizontal_stack": "# horizontal_stack(numsets): Stack numsets in sequence horizonttotaly (column wise).",
        "sqz": "# sqz(self, axis=None): Return a possibly change_shape_tod matrix.",
        "asnumset": "# asnumset(a, dtype=None, order=None): Convert the input to a masked numset of the given data-type.",
        "duplicate": "# duplicate(self, duplicates, axis=None): Repeat elements of an numset.",
        "convert_index_or_arr": "# convert_index_or_arr(indices, shape, order='C'): Converts a flat index or numset of flat indices into a tuple of coordinate numsets.",
        "vectorisation": "# vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Generalized function class.",
        "sep_split": "# sep_split(sep=None, get_maxsep_split=-1): Return a list of the words in the string, using sep as the delimiter string.",
        "difference": "# difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Calculate the n-th discrete difference along the given axis.",
        "logic_and_element_wise": "# logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Compute the truth value of x1 AND x2 element-wise.",
        "convert_into_one_dim": "# convert_into_one_dim(self, order='C'): Return a copy of the numset collapsed into one dimension.",
        "uniq": "# uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Find the uniq elements of an numset.",
        "normlizattion": "# normlizattion(self, *args, **kwargs): Convenience fluent method for :py:func:`normlizattion`.",
        "remove_operation": "# remove_operation(arr, obj, axis=None): Return a new numset with sub-numsets along an axis removed.",
        "create_ones": "# create_ones(shape, dtype=None, order='C', *, like=None): Return a new numset of given shape and type, filled with create_ones.",
        "binoccurrence": "# binoccurrence(x, weights=None, get_minlength=0): Count number of occurrences of each value in numset of non-negative ints.",
        "get_argmax": "# get_argmax(a, axis=None, out=None): Returns the indices of the maximum values along an axis.",
        "apd": "# apd(object, /): Append object to the end of the list.",
        "any_condition": "# any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Test whether any numset element along a given axis evaluates to True.",
        "ifnan": "# ifnan(x, /): Return True if x is a NaN (not a number), and False otherwise.",
        "perform_partition": "# perform_partition(a, kth, axis=-1, kind='introselect', order=None): Perform an indirect partition along the given axis using the algorithm specified by the `kind` keyword.",
        "asview": "# asview(a, *args, **params): asview(self, order='C') Returns a 1D version of self, as a view.",
        "split_array": "# split_array(ary, indices_or_sections, axis=0): Split an numset into multiple sub-numsets.",
        "inverse": "# inverse(a): Compute the (multiplicative) inverse of a matrix.",
        "stick": "# stick(index, object, /): Insert object before index.",
        "find_sorted": "# find_sorted(a, v, side='left', sorter=None): Find indices where elements should be sticked to maintain order.",
        "get_min": "# get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the minimum of an numset or minimum along an axis.",
        "full_value_func": "# full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Return a new numset of given shape and type, masked_fill with `fill_value`.",
        "switching_places": "# switching_places(a, axes=None): Reverse or permute the axes of an numset; returns the modified numset."
    },
    "paraphrased_keyword_description": {
        "numset": "# numset(obj, itemsize=None, copy=True, unicode=None, order=None): Return a `numset`.",
        "stack_col": "# stack_col(x, *args, **params): stack_col(*args, **kwargs) Return a 2-D numset stacked with 1-D numsets by column.",
        "connect": "# connect(numsets, axis=0): Return a numset concatenated with given numsets along the specified axis.",
        "piece": "# piece(self, *args, **kwargs): Returns a piece object used to specify how to slice a sequence.",
        "total_count": "# total_count(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Return the sum of the numset items along a particular axis.",
        "imaginary": "# imaginary(val): Get the complex argument's imaginary part.",
        "absolute": "# absolute(self, *args, **kwargs): Return the absolute value of the given number.",
        "pad_diagonal": "# pad_diagonal(a, val, wrap=False): Fill the main diagonal of any dimensions of the specified numset.",
        "total": "# total(self, axis=None, out=None): Determine if all matrix members along a particular axis are True.",
        "come_from_str": "# come_from_str(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None): Make a record numset out of binary data (do not pass `str` object).",
        "intersection1dim": "# intersection1dim(ar1, ar2, astotal_counte_uniq=False, inverseert=False): Determine if each element of a 1-D numset appears in a second numset.",
        "average": "# average(a, axis=None, dtype=None, out=None, keepdims=False): Calculate the given axis's arithmetic average value.",
        "filter_condition": "# filter_condition(condition, x=None, y=None): filter_condition(condition, [x, y]) Depending on the 'condition,' return items from 'x' or 'y'.",
        "standard_op": "# standard_op(self, axis=None, dtype=None, out=None, ddof=0): Return the numset elements' standard deviation value of the specified axis.",
        "change_shape_to": "# change_shape_to(a, newshape, order='C'): Changes the shape of a numset without affecting its data.",
        "come_from_arrays": "# come_from_arrays(numsetList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None): Turn a (flattened) list of numsets into a record numset.",
        "pile_operation": "# pile_operation(x, *args, **params): pile_operation(*args, **kwargs) Return a numset connected with a series of numsets along a new axis.",
        "hist_operation": "# hist_operation(a, bins=10, range=None, normlizatticreate_onesd=None, weights=None, density=None): Return a dataset's histgram object.",
        "cumulative_sum": "# cumulative_sum(a, axis=None, dtype=None, out=None): Return the elements' total sum along the specified axis.",
        "seting_exclusive_or_one_dim": "# seting_exclusive_or_one_dim(ar1, ar2, astotal_counte_uniq=False): Return the sorted, unique values that are in only one of the input numsets",
        "add_concat": "# add_concat(x1, x2): Return the two numsets' element-wise string or unicode concatenation.",
        "masked_fill": "# masked_fill(a, fill_value=None): Replace the input numset with its masked data filled by the specified value.",
        "remove_masked_data": "# remove_masked_data(x): Return a 1-D numset containing all non-masked data.",
        "convert_type": "# convert_type(self, dtype, copy=True): Cast the numset to a specified type.",
        "get_argmin_value": "# get_argmin_value(a, axis=None, out=None): Returns the minimum values' indices along the specified axis.",
        "arr_range": "# arr_range(*args, **params): arr_range([start,] stop[, step,], dtype=None, *, like=None) Return values that are uniformly spread inside a particular interval.",
        "vertical_stack": "# vertical_stack(tup): Stack numsets in vertical or row wise order.",
        "horizontal_stack": "# horizontal_stack(numsets): Stack numsets in horizontal or column wise order.",
        "sqz": "# sqz(self, axis=None): Remove axes of length one.",
        "asnumset": "# asnumset(a, dtype=None, order=None): Return a masked numset of specified data-type.",
        "duplicate": "# duplicate(self, duplicates, axis=None): Return the numset with specified duplicates.",
        "convert_index_or_arr": "# convert_index_or_arr(indices, shape, order='C'): Return a tuple of coordinate numsets converted from a flat index or numset",
        "vectorisation": "# vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None): vectorisation(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None) Define a vectorized function which takes a nested sequence of objects or beatnum numsets as inputs and returns a single beatnum numset.",
        "sep_split": "# sep_split(sep=None, get_maxsep_split=-1): Return words of the input string using the specified delimiter.",
        "difference": "# difference(a, n=1, axis=-1, prepend=<no value>, apd=<no value>): Return the given axis's n-th discrete difference.",
        "logic_and_element_wise": "# logic_and_element_wise(a, b, *args, **kwargs): logic_and_element_wise(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) Calculate the element-by-element truth value of x1 AND x2..",
        "convert_into_one_dim": "# convert_into_one_dim(self, order='C'): Return a one-dimensional numset replica of the numset.",
        "uniq": "# uniq(ar, return_index=False, return_inverse=False, return_counts=False, axis=None): Return the numset's unique elements.",
        "normlizattion": "# normlizattion(self, *args, **kwargs):  Return one of eight different matrix norms, or one of an infinite number of vector norms.",
        "remove_operation": "# remove_operation(arr, obj, axis=None): Deleted sub-numsets along an axis.",
        "create_ones": "# create_ones(shape, dtype=None, order='C', *, like=None): Create a new numset  of specified shape and type and fill it with ones.",
        "binoccurrence": "# binoccurrence(x, weights=None, get_minlength=0): Return how many times each value appears in the numset of non-negative ints.",
        "get_argmax": "# get_argmax(a, axis=None, out=None): Returns an axis's maximum values indices.",
        "apd": "# apd(object, /): Place the object at last position of the list.",
        "any_condition": "# any_condition(a, axis=None, out=None, keepdims=<no value>, *, where=<no value>): Check if any numset element on a certain axis evaluates to True.",
        "ifnan": "# ifnan(x, /): If x is a NaN (not a number), return True; otherwise, return False.",
        "perform_partition": "# perform_partition(a, kth, axis=-1, kind='introselect', order=None): Using the algorithm indicated by the 'kind' keyword to indirectly partition along the axis.",
        "asview": "# asview(a, *args, **params): asview(self, order='C') Returns the view object of the 1-D self.",
        "split_array": "# split_array(ary, indices_or_sections, axis=0): Divide a numset into several sub-numsets.",
        "inverse": "# inverse(a):Calculate a matrix's (multiplicative) inverse.",
        "stick": "# stick(index, object, /): Place the object before the index.",
        "find_sorted": "# find_sorted(a, v, side='left', sorter=None): Find the indices into a sorted numset a such that if the corresponding elements in v were inserted before the indices, the order of a would be preserved.",
        "get_min": "# get_min(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>): Get the smallest value in a numset or the smallest value along an axis.",
        "full_value_func": "# full_value_func(shape, fill_value, dtype=None, order='C', *, like=None): Masked fill with 'fill value' and return a new numset of the specified form and type.",
        "switching_places": "# switching_places(a, axes=None): Returns the changed numset after reversing or permuting the axes of a numset.",
    }
}