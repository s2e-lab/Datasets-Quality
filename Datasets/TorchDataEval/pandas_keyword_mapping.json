{
    "keyword_to_problems": {
        "average": ["PandasEval/0", "PandasEval/17", "PandasEval/53", "PandasEval/27"],
        "incontain": ["PandasEval/1", "PandasEval/100"],
        "renaming": ["PandasEval/2", "PandasEval/65"],
        "sip": ["PandasEval/3", "PandasEval/30", "PandasEval/38", "PandasEval/42"],
        "convert_list": ["PandasEval/6", "PandasEval/72", "PandasEval/79"],
        "employ": ["PandasEval/8", "PandasEval/17", "PandasEval/25", "PandasEval/32", "PandasEval/48", "PandasEval/85", "PandasEval/96", "PandasEval/34", "PandasEval/27"],
        "to_num": ["PandasEval/8", "PandasEval/12"],
        "sipna": ["PandasEval/9", "PandasEval/17", "PandasEval/32", "PandasEval/63", "PandasEval/91"],
        "KnowledgeFrame": ["PandasEval/11", "PandasEval/21", "PandasEval/60", "PandasEval/67"],
        "adding": ["PandasEval/11", "PandasEval/18", "PandasEval/54", "PandasEval/59", "PandasEval/86"],
        "last_tail": ["PandasEval/13", "PandasEval/73"],
        "clone": ["PandasEval/15"],
        "grouper": ["PandasEval/20", "PandasEval/37", "PandasEval/46", "PandasEval/48", "PandasEval/58", "PandasEval/34"],
        "total_sum": ["PandasEval/20", "PandasEval/96", "PandasEval/99"],
        "Collections": ["PandasEval/10", "PandasEval/17"],
        "ifnull": ["PandasEval/19", "PandasEval/32", "PandasEval/50", "PandasEval/99"],
        "totype": ["PandasEval/21", "PandasEval/22", "PandasEval/26", "PandasEval/70"],
        "choose_dtypes": ["PandasEval/22", "PandasEval/40"],
        "traversal": ["PandasEval/24"],
        "get_min": ["PandasEval/25"],
        "get_max": ["PandasEval/25", "PandasEval/48"],
        "mapping": ["PandasEval/33", "PandasEval/45"],
        "nbiggest": ["PandasEval/35"],
        "flat_underlying": ["PandasEval/36"],
        "sort_the_values": ["PandasEval/37"],
        "final_item": ["PandasEval/37"],
        "shifting": ["PandasEval/39", "PandasEval/58", "PandasEval/83"],
        "unioner": ["PandasEval/41", "PandasEval/61", "PandasEval/98"],
        "counts_value_num": ["PandasEval/43", "PandasEval/81", "PandasEval/88"],
        "renaming_axis": ["PandasEval/43"],
        "reseting_index": ["PandasEval/43", "PandasEval/59", "PandasEval/34"],
        "sample_by_num": ["PandasEval/46"],
        "replacing": ["PandasEval/47", "PandasEval/74"],
        "convert_datetime": ["PandasEval/49", "PandasEval/57"],
        "whatever": ["PandasEval/50", "PandasEval/72", "PandasEval/78"],
        "reindexing": ["PandasEval/51"],
        "concating": ["PandasEval/55", "PandasEval/76"],
        "convert_dict": ["PandasEval/56"],
        "cumulative_sum": ["PandasEval/58"],
        "sorting_index": ["PandasEval/59", "PandasEval/92"],
        "convert_string": ["PandasEval/62"],
        "distinctive": ["PandasEval/64"],
        "remove_duplicates": ["PandasEval/66"],
        "duplicated_values": ["PandasEval/69"],
        "length": ["PandasEval/71"],
        "ifna": ["PandasEval/72", "PandasEval/78"],
        "fillnone": ["PandasEval/75"],
        "getting": ["PandasEval/80"],
        "value_round": ["PandasEval/84"],
        "formating": ["PandasEval/85"],
        "convert_pydatetime": ["PandasEval/87"],
        "division": ["PandasEval/89"],
        "ceiling": ["PandasEval/90"],
        "allocate": ["PandasEval/93"],
        "interst": ["PandasEval/94"],
        "header_num": ["PandasEval/95"],
        "conduct_map": ["PandasEval/97"],
        "total_all": ["PandasEval/97"],
        "standard": ["PandasEval/27"]
    },
    "problem_to_keywords": {
        "PandasEval/0": ["average"],
        "PandasEval/1": ["incontain"],
        "PandasEval/2": ["renaming"],
        "PandasEval/3": ["sip"],
        "PandasEval/6": ["convert_list"],
        "PandasEval/8": ["employ", "to_num"],
        "PandasEval/9": ["sipna"],
        "PandasEval/11": ["KnowledgeFrame", "adding"],
        "PandasEval/12": ["to_num"],
        "PandasEval/13": ["last_tail"],
        "PandasEval/15": ["clone"],
        "PandasEval/20": ["grouper", "total_sum"],
        "PandasEval/10": ["Collections"],
        "PandasEval/17": ["average", "employ", "Collections", "sipna"],
        "PandasEval/18": ["adding"],
        "PandasEval/19": ["ifnull"],
        "PandasEval/21": ["KnowledgeFrame", "totype"],
        "PandasEval/22": ["choose_dtypes", "totype"],
        "PandasEval/24": ["traversal"],
        "PandasEval/25": ["employ", "get_min", "get_max"],
        "PandasEval/26": ["totype"],
        "PandasEval/30": ["sip"],
        "PandasEval/32": ["employ", "ifnull", "sipna"],
        "PandasEval/33": ["mapping"],
        "PandasEval/35": ["nbiggest"],
        "PandasEval/36": ["flat_underlying"],
        "PandasEval/37": ["sort_the_values", "grouper", "final_item"],
        "PandasEval/38": ["sip"],
        "PandasEval/39": ["shifting"],
        "PandasEval/40": ["choose_dtypes"],
        "PandasEval/41": ["unioner"],
        "PandasEval/42": ["sip"],
        "PandasEval/43": ["counts_value_num", "renaming_axis", "reseting_index"],
        "PandasEval/45": ["mapping"],
        "PandasEval/46": ["grouper", "sample_by_num"],
        "PandasEval/47": ["replacing"],
        "PandasEval/48": ["grouper", "employ", "get_max"],
        "PandasEval/49": ["convert_datetime"],
        "PandasEval/50": ["ifnull", "whatever"],
        "PandasEval/51": ["reindexing"],
        "PandasEval/53": ["average"],
        "PandasEval/54": ["adding"],
        "PandasEval/55": ["concating"],
        "PandasEval/56": ["convert_dict"],
        "PandasEval/57": ["convert_datetime"],
        "PandasEval/58": ["grouper", "shifting", "cumulative_sum"],
        "PandasEval/59": ["adding", "sorting_index", "reseting_index"],
        "PandasEval/60": ["KnowledgeFrame"],
        "PandasEval/61": ["unioner"],
        "PandasEval/62": ["convert_string"],
        "PandasEval/63": ["sipna"],
        "PandasEval/64": ["distinctive"],
        "PandasEval/65": ["renaming"],
        "PandasEval/66": ["remove_duplicates"],
        "PandasEval/67": ["KnowledgeFrame"],
        "PandasEval/69": ["duplicated_values"],
        "PandasEval/70": ["totype"],
        "PandasEval/71": ["length"],
        "PandasEval/72": ["ifna", "whatever", "convert_list"],
        "PandasEval/73": ["last_tail"],
        "PandasEval/74": ["replacing"],
        "PandasEval/75": ["fillnone"],
        "PandasEval/76": ["concating"],
        "PandasEval/78": ["ifna", "whatever"],
        "PandasEval/79": ["convert_list"],
        "PandasEval/80": ["getting"],
        "PandasEval/81": ["counts_value_num"],
        "PandasEval/83": ["shifting"],
        "PandasEval/84": ["value_round"],
        "PandasEval/85": ["employ", "formating"],
        "PandasEval/86": ["adding"],
        "PandasEval/87": ["convert_pydatetime"],
        "PandasEval/88": ["counts_value_num"],
        "PandasEval/89": ["division"],
        "PandasEval/90": ["ceiling"],
        "PandasEval/91": ["sipna"],
        "PandasEval/92": ["sorting_index"],
        "PandasEval/93": ["allocate"],
        "PandasEval/94": ["interst"],
        "PandasEval/95": ["header_num"],
        "PandasEval/96": ["employ", "total_sum"],
        "PandasEval/97": ["conduct_map", "total_all"],
        "PandasEval/98": ["unioner"],
        "PandasEval/99": ["ifnull", "total_sum"],
        "PandasEval/100": ["incontain"],
        "PandasEval/34": ["grouper", "employ", "reseting_index"],
        "PandasEval/27": ["employ", "average", "standard"]
    },
    "keyword_description": {
        "average": "# average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average of the values over the requested axis.",
        "incontain": "# incontain(self, values) -> 'np.ndarray': Compute boolean array of whether each value is found in the passed set of values.",
        "renaming": "# renaming(self, name, inplace=False): Alter Index or MultiIndex name.",
        "sip": "# sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Make new Index with passed list of labels deleted.",
        "convert_list": "# convert_list(self, *args, **kwargs): Return a list of the values.",
        "employ": "# employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Apply a function along an axis of the KnowledgeFrame.",
        "to_num": "# to_num(arg, errors='raise', downcast=None): Convert argument to a numeric type.",
        "sipna": "# sipna(self): Return ExtensionArray without NA values.",
        "KnowledgeFrame": "# KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Two-dimensional, size-mutable, potentitotal_ally heterogeneous tabular data.",
        "adding": "# adding(self, other: 'Index | Sequence[Index]') -> 'Index': Append a collection of Index options togettingher.",
        "last_tail": "# last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the final_item `n` rows.",
        "clone": "# clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Make a clone of this object.",
        "grouper": "# grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group KnowledgeFrame using a mappingper or by a Collections of columns.",
        "total_sum": "# total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the total_sum of the values over the requested axis.",
        "Collections": "# Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): One-dimensional ndarray with axis labels (including time collections).",
        "ifnull": "# ifnull(self) -> 'np.ndarray': Detect missing values Missing values (-1 in.",
        "totype": "# totype(self, dtype: 'Dtype | None' = None, clone=True): Change the dtype of a SparseArray.",
        "choose_dtypes": "# choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Return a subset of the KnowledgeFrame's columns based on the column dtypes.",
        "traversal": "# traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Iterate over KnowledgeFrame rows as (index, Collections) pairs.",
        "get_min": "# get_min(self, *, skipna=True, **kwargs): The minimum value of the object.",
        "get_max": "# get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): Return the maximum value of the Index.",
        "mapping": "# mapping(self, mapper, na_action=None): Map values using input correspondence (a dict, Collections, or function).",
        "nbiggest": "# nbiggest(self, n=5, keep='first') -> 'Collections': Return the largest `n` elements.",
        "flat_underlying": "# flat_underlying(self, order='C'): Return an ndarray of the flattened values of the underlying data.",
        "sort_the_values": "# sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return a sorted clone of the index.",
        "final_item": "# final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Select final periods of time collections data based on a date offset.",
        "shifting": "# shifting(self, periods=1, freq=None): Shift index by desired number of time frequency increments.",
        "unioner": "# unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Merge KnowledgeFrame or named Collections objects with a database-style join.",
        "counts_value_num": "# counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return a Collections containing counts of distinctive values.",
        "renaming_axis": "# renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Set the name of the axis for the index or columns.",
        "reseting_index": "# reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index, or a level of it.",
        "sample_by_num": "# sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a random sample_by_num of items from an axis of object.",
        "replacing": "# replacing(old, new, count=-1, /): Return a clone with all occurrences of substring old replacingd by new.",
        "convert_datetime": "# convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Convert argument to datetime.",
        "whatever": "# whatever(self, *args, **kwargs): Return whether whatever element is Truthy.",
        "reindexing": "# reindexing(self, targetting, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create index with targetting's values (move/add/delete values as necessary).",
        "concating": "# concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along a particular axis with optional set logic along the other axes.",
        "convert_dict": "# convert_dict(self, into=<class 'dict'>): Convert Collections to {label -> value} dict or dict-like object.",
        "cumulative_sum": "# cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return cumulative total_sum over a KnowledgeFrame or Collections axis.",
        "sorting_index": "# sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Sort object by labels (along an axis).",
        "convert_string": "# convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Render a KnowledgeFrame to a console-friendly tabular output.",
        "distinctive": "# distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return distinctive values in the index.",
        "remove_duplicates": "# remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Return Index with duplicate values removed.",
        "duplicated_values": "# duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Indicate duplicate index values.",
        "length": "# length(self): Compute the length of each element in the Collections/Index.",
        "ifna": "# ifna(self) -> 'np.ndarray': Detect missing values.",
        "fillnone": "# fillnone(self, value=None, downcast=None): Fill NA/NaN values with the specified value.",
        "getting": "# getting(self, i): Extract element from each component at specified position.",
        "value_round": "# value_round(freq, ambiguous='raise', nonexistent='raise'): Round the Timestamp to the specified resolution.",
        "formating": "# formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Render a string representation of the Index.",
        "convert_pydatetime": "# convert_pydatetime(*args, **kwargs): Convert a Timestamp object to a native Python datetime object.",
        "division": "# division(self, other, axis='columns', level=None, fill_value=None): Get Floating  divisionision of knowledgeframe and other, element-wise (binary operator `true division`).",
        "ceiling": "# ceiling(self, *args, **kwargs): Perform ceiling operation on the data to the specified `freq`.",
        "allocate": "# allocate(self, **kwargs) -> 'KnowledgeFrame': Assign new columns to a KnowledgeFrame.",
        "interst": "# interst(self, other, sort=False): Form the interst of two Index objects.",
        "header_num": "# header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the first `n` rows.",
        "conduct_map": "# conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function to a Dataframe elementwise.",
        "total_all": "# total_all(self, *args, **kwargs): Return whether total_all elements are Truthy.",
        "standard": "# standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return sample_by_num standard deviation over requested axis."
    },
    "paraphrased_keyword_description": {
        "average": "# average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs): Return the average value along the specified axis.",
        "incontain": "# incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.",
        "renaming": "# renaming(self, name, inplace=False): Change the name of the Index or MultiIndex.",
        "sip": "# sip(self, labels, errors: 'str_t' = 'raise') -> 'Index': Create a new Index with no passed labels.",
        "convert_list": "# convert_list(self, *args, **kwargs): Create a list with the passed values.",
        "employ": "# employ(self, func: 'AggFuncType', axis: 'Axis' = 0, raw: 'bool' = False, result_type=None, args=(), **kwargs): Employ a function along one of the KnowledgeFrame's axes.",
        "to_num": "# to_num(arg, errors='raise', downcast=None): Transform the the argumemt to the numeric type.",
        "sipna": "# sipna(self): Return an ExtensionArray that is devoid of NA values.",
        "KnowledgeFrame": "# KnowledgeFrame(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, clone: 'bool | None' = None): Tabular data that is two-dimensional, size-variable, and possibly heterogeneous.",
        "adding": "# adding(self, other: 'Index | Sequence[Index]') -> 'Index': Adding together a group of Index options.",
        "last_tail": "# last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Return the FrameCollection's final `n` rows.",
        "clone": "# clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT': Create a duplicate of this object.",
        "grouper": "# grouper(self, by=None, axis: 'Axis' = 0, level: 'Level | None' = None, as_index: 'bool' = True, sort: 'bool' = True, group_keys: 'bool' = True, squeeze: 'bool | lib.NoDefault' = <no_default>, observed: 'bool' = False, sipna: 'bool' = True) -> 'KnowledgeFrameGroupBy': Group the KnowledgeFrame by a set of columns or group keys.",
        "total_sum": "# total_sum(self, axis=None, skipna=None, level=None, numeric_only=None, getting_min_count=0, **kwargs): Return the summed value of the specified axis.",
        "Collections": "# Collections(data=None, index=None, dtype: 'Dtype | None' = None, name=None, clone: 'bool' = False, fastpath: 'bool' = False): ndarray with axis labels in one-dimension (also time collections).",
        "ifnull": "# ifnull(self) -> 'np.ndarray': Indicates whether values are missing in an array-like object",
        "totype": "# totype(self, dtype: 'Dtype | None' = None, clone=True): Transform a SparseArray's data type.",
        "choose_dtypes": "# choose_dtypes(self, include=None, exclude=None) -> 'KnowledgeFrame': Extract a collection of colums from the KnowledgeFrame based on their dtypes.",
        "traversal": "# traversal(self) -> 'Iterable[tuple[Hashable, Collections]]': Return the rows of the KnowledgeFrame organized in (index, Collections) pairs.",
        "get_min": "# get_min(self, *, skipna=True, **kwargs): Return the object's smallest value.",
        "get_max": "# get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs): The Index's maximum value",
        "mapping": "# mapping(self, mapper, na_action=None): Map the object's values according to an input mapping or function",
        "nbiggest": "# nbiggest(self, n=5, keep='first') -> 'Collections': Get the elements of the object with the n largest values.",
        "flat_underlying": "# flat_underlying(self, order='C'): Flatten the underlying values into an ndarray.",
        "sort_the_values": "# sort_the_values(self, return_indexer: 'bool' = False, ascending: 'bool' = True, na_position: 'str_t' = 'final_item', key: 'Ctotal_allable | None' = None): Return the index as a sorted clone.",
        "final_item": "# final_item(self: 'FrameOrCollections', offset) -> 'FrameOrCollections': Using a date offset to get the last periods of time collections data.",
        "shifting": "# shifting(self, periods=1, freq=None): Increase the number of time frequency increments by the required number.",
        "unioner": "# unioner(self, right: 'FrameOrCollectionsUnion', how: 'str' = 'inner', on: 'IndexLabel | None' = None, left_on: 'IndexLabel | None' = None, right_on: 'IndexLabel | None' = None, left_index: 'bool' = False, right_index: 'bool' = False, sort: 'bool' = False, suffixes: 'Suffixes' = ('_x', '_y'), clone: 'bool' = True, indicator: 'bool' = False, validate: 'str | None' = None) -> 'KnowledgeFrame': Database-style join the named Collections objects or KnowledgeFrame.",
        "counts_value_num": "# counts_value_num(self, normalize: 'bool' = False, sort: 'bool' = True, ascending: 'bool' = False, bins=None, sipna: 'bool' = True): Return the counts of distinctive values.",
        "renaming_axis": "# renaming_axis(self, mappingper=None, index=None, columns=None, axis=None, clone=True, inplace=False): Renaming the index or column's axis.",
        "reseting_index": "# reseting_index(self, level: 'Hashable | Sequence[Hashable] | None' = None, sip: 'bool' = False, inplace: 'bool' = False, col_level: 'Hashable' = 0, col_fill: 'Hashable' = '') -> 'KnowledgeFrame | None': Reset the index of the KnowledgeFrame, and use the default one instead.",
        "sample_by_num": "# sample_by_num(self: 'FrameOrCollections', n=None, frac: 'float | None' = None, replacing: 'bool_t' = False, weights=None, random_state=None, axis: 'Axis | None' = None, ignore_index: 'bool_t' = False) -> 'FrameOrCollections': Return a number of random samples from the object's specified axis.",
        "replacing": "# replacing(old, new, count=-1, /): Return a copy of the object that replaces all instances of the substring old with new.",
        "convert_datetime": "# convert_datetime(arg: 'DatetimeScalarOrArrayConvertible', errors: 'str' = 'raise', dayfirst: 'bool' = False, yearfirst: 'bool' = False, utc: 'bool | None' = None, formating: 'str | None' = None, exact: 'bool' = True, unit: 'str | None' = None, infer_datetime_formating: 'bool' = False, origin='unix', cache: 'bool' = True) -> 'DatetimeIndex | Collections | DatetimeScalar | NaTType | None': Map the format of the argument to datetime.",
        "whatever": "# whatever(self, *args, **kwargs): Return a bool value of whether any element is Truthy.",
        "reindexing": "# reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]': Create an index conditioned on the values of target (move, add, or remove values as needed).",
        "concating": "# concating(objs: 'Iterable[NDFrame] | Mapping[Hashable, NDFrame]', axis=0, join='outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, clone: 'bool' = True) -> 'FrameOrCollectionsUnion': Concatenate monkey objects along one axis, using set logic on the other axes if needed.",
        "convert_dict": "# convert_dict(self, into=<class 'dict'>): Return a dict-like object of the passed Collections",
        "cumulative_sum": "# cumulative_sum(self, axis=None, skipna=True, *args, **kwargs): Return the cumulative total of an axis in the KnowledgeFrame or Collections.",
        "sorting_index": "# sorting_index(self, axis: 'Axis' = 0, level: 'Level | None' = None, ascending: 'bool | int | Sequence[bool | int]' = True, inplace: 'bool' = False, kind: 'str' = 'quicksort', na_position: 'str' = 'final_item', sort_remaining: 'bool' = True, ignore_index: 'bool' = False, key: 'IndexKeyFunc' = None): Return object sorted by labels along the specified axis.",
        "convert_string": "# convert_string(self, buf: 'FilePathOrBuffer[str] | None' = None, columns: 'Sequence[str] | None' = None, col_space: 'int | None' = None, header_numer: 'bool | Sequence[str]' = True, index: 'bool' = True, na_rep: 'str' = 'NaN', formatingters: 'fmt.FormattersType | None' = None, float_formating: 'fmt.FloatFormatType | None' = None, sparsify: 'bool | None' = None, index_names: 'bool' = True, justify: 'str | None' = None, getting_max_rows: 'int | None' = None, getting_min_rows: 'int | None' = None, getting_max_cols: 'int | None' = None, show_dimensions: 'bool' = False, decimal: 'str' = '.', line_width: 'int | None' = None, getting_max_colwidth: 'int | None' = None, encoding: 'str | None' = None) -> 'str | None': Display the output of the KnowledgeFrame as a console-friendly tablular.",
        "distinctive": "# distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT': Return the index's unique values.",
        "remove_duplicates": "# remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT': Remove the duplicate values of the Index.",
        "duplicated_values": "# duplicated_values(self, keep: \"Literal[('first', 'final_item', False)]\" = 'first') -> 'np.ndarray': Return index values that are duplicated.",
        "length": "# length(self): Return the length of each Collections/Index element.",
        "ifna": "# ifna(self) -> 'np.ndarray': Indicate whether there are missing values.",
        "fillnone": "# fillnone(self, value=None, downcast=None): Use the provided value to fill NA/NaN values.",
        "getting": "# getting(self, i): Return the element at specified position.",
        "value_round": "# value_round(freq, ambiguous='raise', nonexistent='raise'): Return the rounded Timestamp to the chosen resolution.",
        "formating": "# formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]': Return the Index as a formatted string.",
        "convert_pydatetime": "# convert_pydatetime(*args, **kwargs): Return the native datetime object in Python.",
        "division": "# division(self, other, axis='columns', level=None, fill_value=None): Get the element-wise floating division of knowledgeframe or other objects.",
        "ceiling": "# ceiling(self, *args, **kwargs): Apply a ceiling operation on the data at the specified frequency.",
        "allocate": "# allocate(self, **kwargs) -> 'KnowledgeFrame': Create new KnowledgeFrame columns.",
        "interst": "# interst(self, other, sort=False): Create the intersection of two Index objects.",
        "header_num": "# header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections': Get the top `n` rows of the frame or collections.",
        "conduct_map": "# conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame': Apply a function element by element to a KnowledgeFrame.",
        "total_all": "# total_all(self, *args, **kwargs): Return a bool value of whether all items are truthy.",
        "standard": "# standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs): Return the standard deviation across the requested axis."
    }
}